import json
import re
from collections import defaultdict, Counter
from datetime import datetime
from typing import Dict, List, Tuple, Optional, Set, Union
import os
import sys
import importlib.util
from pathlib import Path
from functools import lru_cache
from itertools import product, combinations, permutations
import math

# ============ COMPREHENSIVE KNOWLEDGE BASE EXPANSIONS ============

class UltimateExhaustivePaliSemanticKnowledgeBase(ExhaustivePaliSemanticKnowledgeBase):
    """Ultimate comprehensive knowledge base with ALL possible expansions"""
    
    def __init__(self, kaggle_mode=False):
        # Initialize parent class first
        super().__init__(kaggle_mode)
        
        print("üî¨ Initializing Ultimate Comprehensive Knowledge Base...")
        
        # Initialize comprehensive expansions
        self.comprehensive_indeclinables = self._initialize_comprehensive_indeclinables()
        self.comprehensive_technical_vocabulary = self._initialize_comprehensive_technical_vocabulary()
        self.phrasal_expressions = self._initialize_phrasal_expressions()
        self.liturgical_formulas = self._initialize_liturgical_formulas()
        self.proper_names = self._initialize_proper_names()
        self.complete_numerals = self._initialize_complete_numerals()
        self.extended_onomatopoeia = self._initialize_extended_onomatopoeia()
        self.synonyms_antonyms = self._initialize_synonyms_antonyms()
        self.etymology_database = self._initialize_etymology_database()
        self.usage_examples = self._initialize_usage_examples()
        self.metrical_variants = self._initialize_metrical_variants()
        self.register_variations = self._initialize_register_variations()
        self.historical_layers = self._initialize_historical_layers()
        self.semantic_networks = self._initialize_semantic_networks()
        self.canonical_citations = self._initialize_canonical_citations()
        
        print(f"‚úÖ Ultimate knowledge base loaded:")
        print(f"   - Comprehensive indeclinables: {len(self.comprehensive_indeclinables)}")
        print(f"   - Technical vocabulary: {sum(len(v) for v in self.comprehensive_technical_vocabulary.values())}")
        print(f"   - Phrasal expressions: {len(self.phrasal_expressions)}")
        print(f"   - Liturgical formulas: {len(self.liturgical_formulas)}")
        print(f"   - Proper names: {len(self.proper_names)}")
        print(f"   - Complete numerals: {len(self.complete_numerals)}")
        print(f"   - Etymology entries: {len(self.etymology_database)}")
    
    def _initialize_comprehensive_indeclinables(self) -> Dict[str, Dict[str, str]]:
        """Comprehensive list of ALL Pali indeclinables"""
        indeclinables = {
            # Basic particles (existing + expanded)
            "ca": {"type": "conjunction", "meaning": "and", "position": "enclitic", "frequency": 5.0},
            "vƒÅ": {"type": "conjunction", "meaning": "or", "position": "enclitic", "frequency": 4.5},
            "eva": {"type": "emphatic", "meaning": "indeed, just, only", "position": "enclitic", "frequency": 4.8},
            "api": {"type": "particle", "meaning": "also, even, though", "position": "various", "frequency": 4.5},
            "pi": {"type": "particle", "meaning": "also, even", "position": "enclitic", "frequency": 4.3},
            "nu": {"type": "interrogative", "meaning": "?", "position": "enclitic", "frequency": 3.5},
            "kho": {"type": "emphatic", "meaning": "indeed, certainly", "position": "enclitic", "frequency": 4.0},
            "pana": {"type": "adversative", "meaning": "but, however, now", "position": "second", "frequency": 3.8},
            
            # Extended particles
            "hi": {"type": "causal", "meaning": "for, because", "position": "second", "frequency": 4.2},
            "tu": {"type": "adversative", "meaning": "but, however", "position": "enclitic", "frequency": 3.5},
            "kira": {"type": "reportative", "meaning": "it is said, apparently", "position": "second", "frequency": 3.0},
            "nƒÅma": {"type": "emphatic", "meaning": "surely, indeed", "position": "enclitic", "frequency": 3.2},
            "khalu": {"type": "emphatic", "meaning": "indeed, certainly", "position": "second", "frequency": 2.8},
            "kho-pana": {"type": "emphatic", "meaning": "now indeed", "position": "second", "frequency": 2.5},
            "eva-·πÉ": {"type": "emphatic", "meaning": "just so", "position": "enclitic", "frequency": 2.3},
            "sma": {"type": "particle", "meaning": "indeed (archaic)", "position": "enclitic", "frequency": 2.0},
            "ha": {"type": "emphatic", "meaning": "indeed, ah!", "position": "various", "frequency": 2.2},
            "are": {"type": "vocative", "meaning": "hey!, oh!", "position": "initial", "frequency": 2.5},
            "re": {"type": "vocative", "meaning": "hey! (familiar)", "position": "initial", "frequency": 2.0},
            "bho": {"type": "vocative", "meaning": "sir!, friend!", "position": "initial", "frequency": 3.0},
            "bhante": {"type": "vocative", "meaning": "venerable sir!", "position": "initial", "frequency": 3.5},
            "bhaddante": {"type": "vocative", "meaning": "good sir!", "position": "initial", "frequency": 2.8},
            "ƒÅvuso": {"type": "vocative", "meaning": "friend!", "position": "initial", "frequency": 3.2},
            "samma": {"type": "vocative", "meaning": "friend! (to equal)", "position": "initial", "frequency": 2.5},
            
            # Temporal adverbs
            "idƒÅni": {"type": "temporal", "meaning": "now", "position": "initial", "frequency": 3.5},
            "adhunƒÅ": {"type": "temporal", "meaning": "now, at present", "position": "initial", "frequency": 3.0},
            "tadƒÅ": {"type": "temporal", "meaning": "then", "position": "initial", "frequency": 4.0},
            "yadƒÅ": {"type": "temporal", "meaning": "when", "position": "initial", "frequency": 4.2},
            "kadƒÅ": {"type": "temporal", "meaning": "when?", "position": "initial", "frequency": 3.5},
            "sadƒÅ": {"type": "temporal", "meaning": "always", "position": "various", "frequency": 3.8},
            "sabbadƒÅ": {"type": "temporal", "meaning": "always, at all times", "position": "various", "frequency": 3.5},
            "kadƒÅci": {"type": "temporal", "meaning": "sometimes", "position": "various", "frequency": 3.0},
            "purƒÅ·πáa": {"type": "temporal", "meaning": "formerly", "position": "initial", "frequency": 2.5},
            "pubbe": {"type": "temporal", "meaning": "before, formerly", "position": "initial", "frequency": 3.2},
            "pacchƒÅ": {"type": "temporal", "meaning": "afterwards", "position": "initial", "frequency": 3.0},
            "aparena": {"type": "temporal", "meaning": "later", "position": "initial", "frequency": 2.8},
            "sammƒÅ": {"type": "temporal", "meaning": "rightly, properly", "position": "initial", "frequency": 4.0},
            "turito": {"type": "temporal", "meaning": "quickly", "position": "various", "frequency": 2.5},
            "kha·πáena": {"type": "temporal", "meaning": "quickly, in a moment", "position": "various", "frequency": 2.8},
            "ƒÅyati·πÉ": {"type": "temporal", "meaning": "in future", "position": "various", "frequency": 2.5},
            "anƒÅgate": {"type": "temporal", "meaning": "in future", "position": "various", "frequency": 2.3},
            
            # Spatial adverbs
            "idha": {"type": "spatial", "meaning": "here", "position": "initial", "frequency": 4.2},
            "tattha": {"type": "spatial", "meaning": "there", "position": "initial", "frequency": 4.0},
            "yattha": {"type": "spatial", "meaning": "where", "position": "initial", "frequency": 3.8},
            "kattha": {"type": "spatial", "meaning": "where?", "position": "initial", "frequency": 3.0},
            "sabbattha": {"type": "spatial", "meaning": "everywhere", "position": "initial", "frequency": 3.2},
            "a√±√±attha": {"type": "spatial", "meaning": "elsewhere", "position": "initial", "frequency": 2.8},
            "ito": {"type": "spatial", "meaning": "from here", "position": "initial", "frequency": 3.5},
            "tato": {"type": "spatial", "meaning": "from there", "position": "initial", "frequency": 3.8},
            "yato": {"type": "spatial", "meaning": "from where", "position": "initial", "frequency": 3.2},
            "kuto": {"type": "spatial", "meaning": "from where?", "position": "initial", "frequency": 2.8},
            "hura·πÉ": {"type": "spatial", "meaning": "on the other side", "position": "various", "frequency": 2.5},
            "pƒÅra·πÉ": {"type": "spatial", "meaning": "to the other side", "position": "various", "frequency": 2.8},
            "ubhayattha": {"type": "spatial", "meaning": "on both sides", "position": "various", "frequency": 2.3},
            "samantato": {"type": "spatial", "meaning": "all around", "position": "various", "frequency": 2.5},
            "parito": {"type": "spatial", "meaning": "around", "position": "various", "frequency": 2.8},
            "bahiddhƒÅ": {"type": "spatial", "meaning": "outside", "position": "various", "frequency": 2.5},
            "ajjhatta·πÉ": {"type": "spatial", "meaning": "internally", "position": "various", "frequency": 3.0},
            "bƒÅhira·πÉ": {"type": "spatial", "meaning": "externally", "position": "various", "frequency": 2.8},
            
            # Modal adverbs
            "eva·πÉ": {"type": "modal", "meaning": "thus, so", "position": "initial", "frequency": 4.8},
            "ittha·πÉ": {"type": "modal", "meaning": "thus, in this way", "position": "initial", "frequency": 3.5},
            "tathƒÅ": {"type": "modal", "meaning": "thus, so", "position": "initial", "frequency": 4.0},
            "yathƒÅ": {"type": "modal", "meaning": "as, like", "position": "initial", "frequency": 4.5},
            "kathƒÅ": {"type": "modal", "meaning": "how?", "position": "initial", "frequency": 3.8},
            "sabbathƒÅ": {"type": "modal", "meaning": "in every way", "position": "various", "frequency": 3.0},
            "a√±√±athƒÅ": {"type": "modal", "meaning": "otherwise", "position": "various", "frequency": 3.2},
            "nƒÅ√±√±athƒÅ": {"type": "modal", "meaning": "not otherwise", "position": "various", "frequency": 2.5},
            "ekantena": {"type": "modal", "meaning": "absolutely", "position": "various", "frequency": 2.8},
            "niyatƒÅya": {"type": "modal", "meaning": "certainly", "position": "various", "frequency": 2.5},
            "aviparƒ´ta·πÉ": {"type": "modal", "meaning": "without error", "position": "various", "frequency": 2.3},
            
            # Quantitative adverbs
            "bahu·πÉ": {"type": "quantitative", "meaning": "much, many", "position": "various", "frequency": 3.5},
            "appa·πÉ": {"type": "quantitative", "meaning": "little, few", "position": "various", "frequency": 3.0},
            "saki·πÉ": {"type": "quantitative", "meaning": "once", "position": "various", "frequency": 3.8},
            "duvi·πÉ": {"type": "quantitative", "meaning": "twice", "position": "various", "frequency": 3.0},
            "ti·πÉ": {"type": "quantitative", "meaning": "thrice", "position": "various", "frequency": 2.8},
            "punappuna·πÉ": {"type": "quantitative", "meaning": "again and again", "position": "various", "frequency": 3.2},
            "abhikkha·πáa·πÉ": {"type": "quantitative", "meaning": "constantly", "position": "various", "frequency": 2.5},
            "nicca·πÉ": {"type": "quantitative", "meaning": "constantly", "position": "various", "frequency": 3.5},
            "satata·πÉ": {"type": "quantitative", "meaning": "continuously", "position": "various", "frequency": 2.8},
            "ekadƒÅ": {"type": "quantitative", "meaning": "once upon a time", "position": "initial", "frequency": 3.0},
            "bahudhƒÅ": {"type": "quantitative", "meaning": "in many ways", "position": "various", "frequency": 2.5},
            "ekadhƒÅ": {"type": "quantitative", "meaning": "in one way", "position": "various", "frequency": 2.8},
            
            # Negations and prohibitions
            "na": {"type": "negation", "meaning": "not", "position": "preverbal", "frequency": 5.0},
            "no": {"type": "negation", "meaning": "not", "position": "preverbal", "frequency": 4.2},
            "mƒÅ": {"type": "prohibitive", "meaning": "don't, may not", "position": "preverbal", "frequency": 4.0},
            "natthi": {"type": "negation", "meaning": "there is not", "position": "predicative", "frequency": 3.8},
            "nƒÅma": {"type": "negation", "meaning": "not even", "position": "emphatic", "frequency": 3.0},
            "neta·πÉ": {"type": "negation", "meaning": "this is not", "position": "predicative", "frequency": 2.5},
            "nissa·πÉsaya·πÉ": {"type": "negation", "meaning": "without doubt", "position": "adverbial", "frequency": 2.8},
            
            # Interjections
            "aho": {"type": "interjection", "meaning": "oh!, alas!", "position": "initial", "frequency": 2.8},
            "bho": {"type": "interjection", "meaning": "sir!, friend!", "position": "initial", "frequency": 3.0},
            "are": {"type": "interjection", "meaning": "hey!", "position": "initial", "frequency": 2.5},
            "je": {"type": "interjection", "meaning": "oh!", "position": "initial", "frequency": 2.0},
            "handa": {"type": "interjection", "meaning": "come on!, well!", "position": "initial", "frequency": 2.8},
            "sƒÅdhu": {"type": "interjection", "meaning": "well done!", "position": "exclamatory", "frequency": 3.5},
            "lahu": {"type": "interjection", "meaning": "quickly!", "position": "imperative", "frequency": 2.5},
            "ayya·πÉ": {"type": "interjection", "meaning": "sir!", "position": "vocative", "frequency": 2.3},
            
            # Conditional and concessive
            "sace": {"type": "conditional", "meaning": "if", "position": "initial", "frequency": 4.0},
            "yadi": {"type": "conditional", "meaning": "if", "position": "initial", "frequency": 4.2},
            "yadƒÅ": {"type": "conditional", "meaning": "when", "position": "initial", "frequency": 4.0},
            "yadƒÅyida·πÉ": {"type": "conditional", "meaning": "since", "position": "initial", "frequency": 2.5},
            "yadida·πÉ": {"type": "conditional", "meaning": "namely", "position": "explanatory", "frequency": 2.8},
            "viya": {"type": "comparative", "meaning": "like, as if", "position": "postpositional", "frequency": 3.5},
            "iva": {"type": "comparative", "meaning": "like, as if", "position": "postpositional", "frequency": 3.8},
            "ma√±√±e": {"type": "comparative", "meaning": "I think, as it were", "position": "parenthetical", "frequency": 2.5},
            
            # Quotative
            "ti": {"type": "quotative", "meaning": "thus, quote marker", "position": "final", "frequency": 4.8},
            "iti": {"type": "quotative", "meaning": "thus, end quote", "position": "final", "frequency": 4.5},
            "kicca": {"type": "quotative", "meaning": "saying", "position": "postverbal", "frequency": 2.0},
            
            # Emphatic and intensive
            "yeva": {"type": "emphatic", "meaning": "just, even", "position": "enclitic", "frequency": 3.8},
            "va": {"type": "emphatic", "meaning": "just", "position": "enclitic", "frequency": 3.5},
            "sma": {"type": "emphatic", "meaning": "indeed", "position": "enclitic", "frequency": 2.0},
            "vata": {"type": "emphatic", "meaning": "surely, indeed", "position": "initial", "frequency": 2.8},
            "kho-nu": {"type": "emphatic", "meaning": "pray tell", "position": "interrogative", "frequency": 2.5},
            "ki·πÉnu": {"type": "emphatic", "meaning": "what indeed?", "position": "interrogative", "frequency": 2.3},
            
            # Causal and explanatory
            "yasmƒÅ": {"type": "causal", "meaning": "because", "position": "initial", "frequency": 3.5},
            "yato": {"type": "causal", "meaning": "since", "position": "initial", "frequency": 3.2},
            "tasmƒÅ": {"type": "causal", "meaning": "therefore", "position": "initial", "frequency": 4.0},
            "tena": {"type": "causal", "meaning": "therefore", "position": "initial", "frequency": 3.8},
            "atha": {"type": "sequential", "meaning": "then, now", "position": "initial", "frequency": 4.2},
            "apara·πÉ": {"type": "sequential", "meaning": "furthermore", "position": "initial", "frequency": 3.0},
            "ki√±ca": {"type": "additive", "meaning": "moreover", "position": "initial", "frequency": 2.8},
            "bh≈´yo": {"type": "additive", "meaning": "more, further", "position": "adverbial", "frequency": 2.5},
        }
        
        # Add combination particles
        combinations = {
            "cƒÅpi": {"type": "conjunction", "meaning": "and also", "frequency": 3.0},
            "vƒÅpi": {"type": "conjunction", "meaning": "or also", "frequency": 2.8},
            "evampi": {"type": "emphatic", "meaning": "even so", "frequency": 2.5},
            "tenapi": {"type": "causal", "meaning": "therefore also", "frequency": 2.3},
            "athapi": {"type": "concessive", "meaning": "even though", "frequency": 2.5},
            "yathƒÅpi": {"type": "comparative", "meaning": "just as", "frequency": 3.0},
            "tasmƒÅpi": {"type": "causal", "meaning": "therefore indeed", "frequency": 2.5},
            "yadƒÅpi": {"type": "temporal", "meaning": "even when", "frequency": 2.3},
            "yasmƒÅpi": {"type": "causal", "meaning": "because indeed", "frequency": 2.0},
            "ki√±cƒÅpi": {"type": "concessive", "meaning": "although", "frequency": 2.8},
            "yƒÅvadeva": {"type": "limitative", "meaning": "just as far as", "frequency": 2.5},
            "tƒÅvadeva": {"type": "limitative", "meaning": "just so far", "frequency": 2.3},
        }
        
        indeclinables.update(combinations)
        return indeclinables
    
    def _initialize_comprehensive_technical_vocabulary(self) -> Dict[str, List[str]]:
        """Comprehensive technical vocabulary for ALL fields"""
        return {
            "abhidhamma": [
                # Consciousness and mental factors (89 items)
                "vi√±√±ƒÅ·πáa", "citta", "cetasika", "khandha", "dhƒÅtu", "ƒÅyatana",
                "phassa", "vedanƒÅ", "sa√±√±ƒÅ", "cetanƒÅ", "ekaggatƒÅ", "jƒ´vitindriya",
                "manasikƒÅra", "vitakka", "vicƒÅra", "adhimokkha", "viriya", "pƒ´ti",
                "chanda", "lobha", "dosa", "moha", "alobha", "adosa", "amoha",
                "saddhƒÅ", "sati", "hiri", "ottappa", "upadƒÅna", "kilesa", "sa·πÉyojana",
                "anusaya", "nƒ´vara·πáa", "kƒÅmacchanda", "byƒÅpƒÅda", "thƒ´namiddha",
                "uddhaccakukkucca", "vicikicchƒÅ", "avidyƒÅ", "avijjƒÅ", "sa·πÉskƒÅra",
                "vijjƒÅ", "sammƒÅdi·π≠·π≠hi", "sammƒÅsa·πÖkappa", "sammƒÅvƒÅcƒÅ", "sammƒÅkammanta",
                "sammƒÅƒÅjƒ´va", "sammƒÅvƒÅyƒÅma", "sammƒÅsati", "sammƒÅsamƒÅdhi",
                "sakkƒÅyadi·π≠·π≠hi", "vicikicchƒÅ", "sƒ´labbataparƒÅmƒÅsa", "kƒÅmarƒÅga",
                "pa·π≠igha", "r≈´parƒÅga", "ar≈´parƒÅga", "mƒÅna", "uddhacca", "avijjƒÅ",
                "r≈´pƒÅvacara", "ar≈´pƒÅvacara", "kƒÅmƒÅvacara", "lokuttara",
                "kusala", "akusala", "abyƒÅkata", "kammaja", "cittaja", "utuja",
                "ƒÅhƒÅraja", "r≈´pƒÅr≈´pa", "nƒÅmar≈´pa", "tilakkhana", "anicca",
                "dukkha", "anattƒÅ", "su√±√±atƒÅ", "appanihita", "animitta",
                "pa√±√±atti", "paramattha", "sammuti", "nijjƒÅna", "pavicƒÅra",
                "upacƒÅra", "appanƒÅ", "javana", "tadƒÅlambana", "pa√±cadvƒÅrƒÅvajjana",
                "manodvƒÅrƒÅvajjana", "cakkhuvi√±√±ƒÅ·πáa", "sotavi√±√±ƒÅ·πáa", "ghƒÅnavi√±√±ƒÅ·πáa",
                "jivhƒÅvi√±√±ƒÅ·πáa", "kƒÅyavi√±√±ƒÅ·πáa", "manovi√±√±ƒÅ·πáa", "ƒÅpƒÅyika",
            ],
            
            "vinaya": [
                # Monastic rules and procedures (200+ items)
                "pƒÅrƒÅjika", "sa·πÖghƒÅdisesa", "aniyata", "nissaggiya", "pƒÅcittiya",
                "pƒÅ·π≠idesanƒ´ya", "sekhiya", "adhikara·πáasamatha", "garudhamma",
                "sikkhƒÅpada", "ovƒÅda", "anuvƒÅda", "sa·πÉvƒÅsa", "nissaya", "parivƒÅsa",
                "mƒÅnatta", "abbhƒÅna", "osƒÅra·πáa", "ukkhepaniya", "pa·π≠isƒÅra·πáiya",
                "tajjaniya", "niyassƒÅnubandha", "pabbƒÅjaniya", "brahmada·πá·∏ça",
                "uposatha", "pavƒÅra·πáƒÅ", "kathina", "cƒ´varuppƒÅda", "vassa", "hemanta",
                "gimha", "sƒ´mƒÅ", "ticƒ´varena", "nirƒÅmisa", "sƒÅmisa", "abhisa·πÖkhƒÅra",
                "anabhisa·πÖkhƒÅra", "rajokallola", "bhojanadƒÅna", "pi·πá·∏çapƒÅta",
                "senƒÅsana", "gilƒÅnapaccaya", "bhesajja", "ƒÅgantukƒÅvƒÅsa", "gamikƒÅvƒÅsa",
                "sabhƒÅgƒÅpatti", "asabhƒÅgƒÅpatti", "sƒÅvasesƒÅpatti", "anavasesƒÅpatti",
                "suddha", "missaka", "parihƒÅra", "akuppa", "kuppa", "lƒÅmaka",
                "thera", "navaka", "majjhima", "adhicitta", "adhipa√±√±ƒÅ", "adhisƒ´la",
                "vinayadhara", "dhammakathika", "jhƒÅyƒ´", "pa·πÉsuk≈´lika", "sosƒÅnika",
                "rukkham≈´lika", "abbhokƒÅsika", "nesajjika", "yathƒÅsanthatika",
                "tecƒ´varika", "sapadƒÅnacƒÅrƒ´", "khalupacchƒÅbhattika", "pattapi·πá·∏çika",
                "ƒÅra√±√±ika", "ekƒÅsanika", "pa·πÉsuk≈´la", "rukkham≈´la", "sosƒÅna",
                "abbhokƒÅsa", "nesajja", "yathƒÅsanthata", "tecƒ´vara", "sapadƒÅna",
                "khalupacchƒÅbhatta", "pattapi·πá·∏ça", "ƒÅra√±√±aka", "ekƒÅsana",
                "upajjhƒÅya", "ƒÅcƒÅriya", "saddhivihƒÅrika", "antevƒÅsika", "kallyƒÅ·πáamitta",
                "pƒÅpamitra", "ƒÅpadƒÅsu", "ovƒÅdapa·π≠ikara", "suss≈´sƒÅ", "sovacassatƒÅ",
                "abhivƒÅdana", "paccu·π≠·π≠hƒÅna", "a√±jalikamma", "sƒÅmƒ´cikamma",
                "sakkƒÅra", "garukƒÅra", "mƒÅna", "p≈´jƒÅ", "ƒÅpaciti", "sƒÅmanta",
                "upasampadƒÅ", "pabbajjƒÅ", "nisƒ´dana", "paccupa·π≠·π≠hƒÅna", "veyya",
                "veyya-avacca", "gihƒ´", "pabbajita", "bhikkhu", "bhikkhunƒ´",
                "sikkhamƒÅnƒÅ", "sƒÅma·πáera", "sƒÅma·πáerƒ´", "dƒÅyaka", "dƒÅyikƒÅ",
                "gahapatƒ´", "kulaputra", "kuladhƒ´tƒÅ", "mahƒÅpurisa", "mahƒÅmatta",
                "rƒÅjƒÅ", "mahƒÅrƒÅjƒÅ", "cakkavatti", "adhipatƒ´", "issara", "vasavatti",
                "mahƒÅsƒÅmƒ´", "sƒÅmƒ´", "pati", "bhariyƒÅ", "putta", "dhƒ´tƒÅ", "mƒÅtu",
                "pitu", "bhƒÅtu", "bhagini", "ayyƒÅ", "tƒÅta", "amma", "nƒÅti", "√±ƒÅti",
            ],
            
            "meditation": [
                # Meditation practices and states (150+ items)
                "jhƒÅna", "samƒÅdhi", "samatha", "vipassanƒÅ", "satipa·π≠·π≠hƒÅna", "ƒÅnƒÅpƒÅnasati",
                "kƒÅyagatƒÅsati", "mara·πáasati", "buddhƒÅnussati", "dhammƒÅnussati",
                "sa·πÖghƒÅnussati", "sƒ´lƒÅnussati", "cƒÅgƒÅnussati", "devatƒÅnussati",
                "upasamƒÅnussati", "ƒÅsubha", "maranasa√±√±ƒÅ", "ƒÅhƒÅre-pa·π≠ik≈´lasa√±√±ƒÅ",
                "sabbaloke-anabhiratasa√±√±ƒÅ", "anicca-sa√±√±ƒÅ", "anicce-dukkha-sa√±√±ƒÅ",
                "dukkhe-anattƒÅ-sa√±√±ƒÅ", "pahƒÅna-sa√±√±ƒÅ", "virƒÅga-sa√±√±ƒÅ", "nirodha-sa√±√±ƒÅ",
                "kasi·πáa", "pathavƒ´-kasi·πáa", "ƒÅpo-kasi·πáa", "tejo-kasi·πáa", "vƒÅyo-kasi·πáa",
                "nƒ´la-kasi·πáa", "pƒ´ta-kasi·πáa", "lohita-kasi·πáa", "odƒÅta-kasi·πáa",
                "ƒÅloka-kasi·πáa", "ƒÅkƒÅsa-kasi·πáa", "parimandala", "nimitta", "uggaha-nimitta",
                "pa·π≠ibhƒÅga-nimitta", "upacƒÅra", "appanƒÅ", "vikkhambhana", "tada·πÖga",
                "samuccheda", "pa·π≠ippassaddhi", "adhimutta", "pariyodƒÅta", "kammaniya",
                "·π≠hita", "ƒÅne√±ja", "mettƒÅ", "karu·πáƒÅ", "muditƒÅ", "upekkhƒÅ",
                "brahmavihƒÅra", "appama√±√±ƒÅ", "phara·πáƒÅ", "byƒÅpana", "ƒÅy≈´hana",
                "vitthƒÅra", "ƒÅkƒÅsƒÅna√±cƒÅyatana", "vi√±√±ƒÅ·πáa√±cƒÅyatana", "ƒÅki√±ca√±√±ƒÅyatana",
                "nevasa√±√±ƒÅnƒÅsa√±√±ƒÅyatana", "ar≈´pajjhƒÅna", "r≈´pajjhƒÅna", "kƒÅmƒÅvacara",
                "jhƒÅyƒ´", "samƒÅpannakas", "vu·π≠·π≠hƒÅnakas", "kallita", "muduka", "kammaniya",
                "pagu·πáa", "ujuka", "adhimutta", "pariyodƒÅta", "·π≠hita", "ƒÅne√±ja",
                "vitakka", "vicƒÅra", "pƒ´ti", "sukha", "ekaggatƒÅ", "upekkhƒÅ",
                "cetovimuttƒ´", "pa√±√±ƒÅvimuttƒ´", "ubhatobhƒÅgavimuttƒ´", "kƒÅyasakkhƒ´",
                "di·π≠·π≠hippatta", "saddhƒÅvimutta", "dhammƒÅnusƒÅrƒ´", "saddhƒÅnusƒÅrƒ´",
                "iddhipƒÅda", "balƒÅni", "bojjha·πÖga", "magga·πÖga", "sacca", "ariyasacca",
                "dukkha", "samudaya", "nirodha", "magga", "sammƒÅdi·π≠·π≠hi", "sammƒÅsa·πÖkappa",
                "sammƒÅvƒÅcƒÅ", "sammƒÅkammanta", "sammƒÅƒÅjƒ´va", "sammƒÅvƒÅyƒÅma", "sammƒÅsati",
                "sammƒÅsamƒÅdhi", "saddhindriya", "viriyindriya", "satindriya",
                "samƒÅdhindriya", "pa√±√±indriya", "saddhƒÅbala", "viriyabala", "satibala",
                "samƒÅdhibala", "pa√±√±ƒÅbala", "satisambojjha·πÖga", "dhammavicayasambojjha·πÖga",
                "viriyasambojjha·πÖga", "pƒ´tisambojjha·πÖga", "passaddhisambojjha·πÖga",
                "samƒÅdhisambojjha·πÖga", "upekkhƒÅsambojjha·πÖga", "chandrƒÅga", "viriya",
                "citta", "vƒ´ma·πÉsƒÅ", "padhƒÅna", "sa·πÉyama", "avyƒÅpƒÅda", "nƒ´vara·πáa",
            ],
            
            "cosmology": [
                # Cosmological terms (100+ items)
                "cakkavƒÅ·∏∑a", "lokadhƒÅtu", "sahassac≈´·∏∑anikƒÅ", "dvisahassƒ´", "tisahassƒ´",
                "brahmaloka", "devaloka", "manussaloka", "tiracchƒÅnaloka", "petaloka",
                "asuraloka", "niraya", "avƒ´ci", "mahƒÅniraya", "ussadaniraya",
                "khuddaniraya", "sa√±jƒ´va", "kƒÅlasutta", "sa·πÖghƒÅta", "roruva",
                "mahƒÅroruva", "tƒÅvati·πÉsa", "yƒÅma", "tusita", "nimmƒÅnaratƒ´",
                "paranimmitavasavattƒ´", "brahmakƒÅyika", "brahmapurohita", "mahƒÅbrahmƒÅ",
                "parittƒÅbha", "appamƒÅ·πáƒÅbha", "ƒÅbhassara", "parittasubha", "appamƒÅ·πáasubha",
                "subhaki·πáha", "vehapphala", "asa√±√±asatta", "suddhƒÅvƒÅsa", "avihƒÅ",
                "atappƒÅ", "sudassƒÅ", "sudassƒ´", "akani·π≠·π≠ha", "ƒÅkƒÅsƒÅna√±cƒÅyatana",
                "vi√±√±ƒÅ·πáa√±cƒÅyatana", "ƒÅki√±ca√±√±ƒÅyatana", "nevasa√±√±ƒÅnƒÅsa√±√±ƒÅyatana",
                "gati", "upapatti", "cutipa·π≠isandhi", "gandhabba", "antarƒÅbhava",
                "pu√±√±abhisa·πÖkhƒÅra", "apu√±√±abhisa·πÖkhƒÅra", "ƒÅne√±jƒÅbhisa·πÖkhƒÅra",
                "punabbhava", "jƒÅti", "jarƒÅ", "mara·πáa", "cut≈´papƒÅta", "sƒÅsavatavƒÅda",
                "ucchedavƒÅda", "sassatavƒÅda", "antavƒÅ", "anantavƒÅ", "ta·πÉjƒ´va",
                "ta·πÉsarƒ´ra", "a√±√±ajƒ´va", "a√±√±asarƒ´ra", "hoti", "na-hoti", "hoti-ca-na-ca-hoti",
                "nevahoti-na-na-hoti", "atƒ´ta·πÉ", "anƒÅgata·πÉ", "paccuppanna·πÉ", "kha·πáika",
                "santati", "kƒÅla", "samaya", "addha", "mƒÅsa", "pakkhƒÅ", "ahoratti·πÉ",
                "divaso", "ratti·πÉ", "kha·πáo", "lava", "muhutta", "yuga", "kappa",
                "asa·πÖkheyya", "mahƒÅkappa", "antarkappa", "sa·πÉva·π≠·π≠a", "sa·πÉva·π≠·π≠a·π≠·π≠hƒÅyƒ´",
                "viva·π≠·π≠a", "viva·π≠·π≠a·π≠·π≠hƒÅyƒ´", "ƒÅyukappa", "kosala", "brahma", "indra",
                "yakkha", "rakkhasa", "gandhabba", "kumbha·πá·∏ça", "nƒÅga", "supa·πá·πáa",
                "garula", "mahoraga", "asura", "deva", "manussƒÅ", "tiracchƒÅna",
                "peta", "nerayika", "cattƒÅro-mahƒÅrƒÅjƒÅno", "dhatara·π≠·π≠ha", "vir≈´·∏∑haka",
                "vir≈´pakkha", "vessava·πáa", "sakka", "indra", "vƒÅsava", "kosiya",
                "maghavƒÅ", "purindada", "sahassakkha", "sujampati", "brahmƒÅ",
                "sahampati", "baka", "pajƒÅpati", "santu·π≠·π≠ha", "sunimmita", "vasavattin",
                "mƒÅra", "mƒÅrapakkhikƒÅ", "mƒÅrasenƒÅ", "pƒÅpimant", "namuci", "ka·πáha",
                "adhipati", "antaka", "maccu", "kƒÅla", "kƒÅlika", "d≈´sƒ´", "pamattabandhu",
            ],
            
            "canonical_texts": [
                # Canonical literature (150+ items)
                "sutta", "geyya", "veyyƒÅkara·πáa", "gƒÅthƒÅ", "udƒÅna", "itivuttaka",
                "jƒÅtaka", "abbhutadhamma", "vedalla", "dhammapada", "therƒÅpadƒÅna",
                "therƒ´gƒÅthƒÅ", "theragƒÅthƒÅ", "jƒÅtakatthava·πá·πáanƒÅ", "mahƒÅparinibbƒÅnasutta",
                "brahmajƒÅlasutta", "sƒÅma√±√±aphalasutta", "mahƒÅsatipa·π≠·π≠hƒÅnasutta",
                "mahƒÅparittƒÅna", "ratanasutta", "kara·πáƒ´yamettƒÅsutta", "khandhasutta",
                "girimƒÅnandasutta", "bojjha·πÖgasutta", "pubba·πáhasamƒÅdhisutta",
                "saccasutta", "vattasutta", "anattalakkha·πáasutta", "sammƒÅsambuddhasutta",
                "dhammacakkappavattanasutta", "pa√±cavaggiyasutta", "ƒÅdittapariyƒÅyasutta",
                "mahƒÅkassapatherasutta", "uruvelpakassapasutta", "gayƒÅkassapasutta",
                "nadƒ´kassapasutta", "yassasutta", "brahmƒÅyƒÅcanasutta", "mƒÅrasa·πÉyutta",
                "devaputtasa·πÉyutta", "kosalasa·πÉyutta", "mƒÅragƒÅthƒÅ", "bhikkhunƒ´sa·πÉyutta",
                "brahma·πáasa·πÉyutta", "vanapatisa·πÉyutta", "yakkhasa·πÉyutta", "suppa·πá·πáasa·πÉyutta",
                "gandhabbakƒÅyikadevaputrasa·πÉyutta", "valƒÅhakasa·πÉyutta", "khandhasa·πÉyutta",
                "rƒÅdhasa·πÉyutta", "di·π≠·π≠hisa·πÉyutta", "okkantasa·πÉyutta", "uppƒÅdasa·πÉyutta",
                "kilesesa·πÉyutta", "sƒ´lasampadƒÅsa·πÉyutta", "samƒÅdhisampadƒÅsa·πÉyutta",
                "pa√±√±ƒÅsampadƒÅsa·πÉyutta", "vimuttisampadƒÅsa·πÉyutta", "vimutti√±ƒÅ·πáadassanasampadƒÅsa·πÉyutta",
                "khandhavagga", "sa·∏∑ƒÅyatanavagga", "nidƒÅnavagga", "maggavagga",
                "mahƒÅvagga", "nikƒÅya", "pi·π≠aka", "vinayapi·π≠aka", "suttantapi·π≠aka",
                "abhidhammapi·π≠aka", "dƒ´ghanikƒÅya", "majjhimanikƒÅya", "sa·πÉyuttanikƒÅya",
                "a·πÖguttaranikƒÅya", "khuddakanikƒÅya", "suttavibha·πÖga", "khandhaka",
                "parivƒÅra", "dhammasa·πÖga·πáƒ´", "vibha·πÖga", "dhƒÅtukathƒÅ", "puggalapa√±√±atti",
                "kathƒÅvatthu", "yamaka", "pa·π≠·π≠hƒÅna", "cariyƒÅpi·π≠aka", "apadƒÅna",
                "buddhava·πÉsa", "vimƒÅnavatthu", "petavatthu", "niddesa", "pa·π≠isambhidƒÅmagga",
                "a·π≠·π≠hakathƒÅ", "·π≠ƒ´kƒÅ", "anu·π≠ƒ´kƒÅ", "yojanƒÅ", "va·πá·πáanƒÅ", "nidƒÅna",
                "uddƒÅna", "gƒÅthƒÅ", "nigama", "anuloma", "pa·π≠iloma", "paccupanna",
                "atƒ´ta", "anƒÅgata", "sƒÅsava", "anƒÅsava", "sa·πÖkhata", "asa·πÖkhata",
                "r≈´pa", "ar≈´pa", "pariyƒÅpanna", "apariyƒÅpanna", "vedanƒÅ", "sa√±√±ƒÅ",
                "sa·πÖkhƒÅra", "vi√±√±ƒÅ·πáa", "r≈´pakkhandha", "vedanƒÅkkhandha", "sa√±√±ƒÅkkhandha",
                "sa·πÖkhƒÅrakkhandha", "vi√±√±ƒÅ·πáakkhandha", "pa√±√±atti", "adhivacana",
                "desanƒÅ", "ovƒÅda", "anusƒÅsanƒ´", "kathƒÅ", "sallƒÅpa", "mantanƒÅ",
                "vi√±√±ƒÅpana", "pucchƒÅ", "vissajjanƒÅ", "paripucchƒÅ", "pa·π≠ipucchƒÅ",
                "yƒÅcana", "adhi·π≠·π≠hƒÅna", "pa·πáidhi", "ceto-pa·πáidhi", "pubbenivƒÅsa",
                "cut≈´papƒÅta", "ƒÅsavakkhaya", "tevijja", "chalabhi√±√±ƒÅ", "dasabala",
                "catuvesƒÅrajja", "cattƒÅri-satipa·π≠·π≠hƒÅna", "cattƒÅri-sammappadhƒÅna",
                "cattƒÅro-iddhipƒÅda", "pa√±cindriya", "pa√±cabala", "sattabojjha·πÖga",
                "ariyaa·π≠·π≠ha·πÖgikamagga", "cattƒÅri-ariyasacca", "bƒÅrƒÅnasƒ´", "isipatana",
                "migadƒÅya", "jetavana", "anƒÅthapi·πá·∏çikassa-ƒÅrƒÅma", "pubbƒÅrƒÅma",
                "migƒÅramƒÅtupƒÅsƒÅda", "mahƒÅvana", "k≈´·π≠ƒÅgƒÅrasƒÅlƒÅ", "gijjhak≈´·π≠a",
                "indak≈´·π≠a", "vebhƒÅra", "rajahamahƒÅvihƒÅra", "nƒÅ·∏∑andƒÅ", "kalandakanivƒÅpa",
                "bambhace·π≠iya", "ƒÅmalaka", "ko·π≠igƒÅma", "nƒÅdikƒÅ", "pƒÅvƒÅ", "kusinƒÅrƒÅ",
                "upavattana", "sƒÅlavana", "kusavati", "pƒÅ·π≠ali", "vesƒÅli", "mahƒÅvana",
                "k≈´·π≠ƒÅgƒÅrasƒÅlƒÅ", "campƒÅ", "gaggarƒÅpokkhara·πáƒ´", "bhaddiya", "kapilavatthu",
                "nigrodhƒÅrƒÅma", "uruvelƒÅ", "nera√±jarƒÅ", "ajapƒÅlanigrodha", "buddhagayƒÅ",
                "bodhima·πá·∏ça", "ratanaca·πÖkama", "cankamana", "th≈´pa", "cetiya",
                "vihƒÅra", "ƒÅrƒÅma", "upa·π≠·π≠hƒÅnasƒÅlƒÅ", "jantƒÅghara", "kappiyaku·π≠i",
                "paribhojanƒ´ya", "gilƒÅnapaccayabhesajja-parikkhƒÅra", "puggala",
            ],
            
            "philosophy": [
                # Philosophical concepts (120+ items)
                "dhamma", "sacca", "ariyasacca", "dukkha", "samudaya", "nirodha",
                "magga", "anicca", "anattƒÅ", "tilakkhana", "pa·π≠iccasamuppƒÅda",
                "idappaccayatƒÅ", "nidƒÅna", "paccaya", "hetu", "phala", "vipƒÅka",
                "kamma", "kiriya", "cetanƒÅ", "adhikƒÅra", "kusala", "akusala",
                "abyƒÅkata", "pu√±√±a", "pƒÅpa", "sƒÅva", "anƒÅsava", "sa·πÖkhata",
                "asa·πÖkhata", "conditioned", "unconditioned", "lokiya", "lokuttara",
                "sammuti", "paramattha", "pa√±√±atti", "adhivacana", "nƒÅma", "r≈´pa",
                "nƒÅmar≈´pa", "khandha", "dhƒÅtu", "ƒÅyatana", "gati", "upapatti",
                "cutipa·π≠isandhi", "pavatti", "bhava·πÖga", "mara·πáa", "jƒÅti",
                "jarƒÅ", "vyƒÅdhi", "soka", "parideva", "upƒÅyƒÅsa", "domanassa",
                "uppadƒÅna", "kilesa", "ƒÅsava", "ogha", "yuga", "gantha",
                "kƒÅya-gantha", "vƒÅci-gantha", "mano-gantha", "lobha", "dosa",
                "moha", "alobha", "adosa", "amoha", "saddhƒÅ", "sƒ´la", "dƒÅna",
                "bhƒÅvanƒÅ", "pa√±√±ƒÅ", "vipassanƒÅ", "samatha", "vimutti", "moksha",
                "nibbƒÅna", "kaivalya", "amata", "amata-dhƒÅtu", "nibbƒÅna-dhƒÅtu",
                "sopadisesa", "anupƒÅdisesa", "di·π≠·π≠hadhamma", "parinibbƒÅna",
                "khandhaparinibbƒÅna", "dhƒÅtuparinibbƒÅna", "sƒÅsava", "anƒÅsava",
                "sa·πÖkhata", "asa·πÖkhata", "kamma", "vipƒÅka", "kiriya", "kusala",
                "akusala", "abyƒÅkata", "kƒÅma", "bhava", "di·π≠·π≠hi", "avijjƒÅ",
                "ta·πáhƒÅ", "upƒÅdƒÅna", "bhava", "jƒÅti", "jarƒÅmara·πáa", "dukkha",
                "sammƒÅdi·π≠·π≠hi", "micchƒÅdi·π≠·π≠hi", "di·π≠·π≠higata", "di·π≠·π≠higahana",
                "di·π≠·π≠hikantƒÅra", "di·π≠·π≠hivis≈´ka", "di·π≠·π≠hivipphandita", "di·π≠·π≠hisa√±√±ojana",
                "sakkƒÅyadi·π≠·π≠hi", "vicikicchƒÅ", "sƒ´labbataparƒÅmƒÅsa", "kƒÅmarƒÅga",
                "pa·π≠igha", "r≈´parƒÅga", "ar≈´parƒÅga", "mƒÅna", "uddhacca", "avijjƒÅ",
                "dasa-sa√±√±ojana", "orambhƒÅgiya", "uddhambhƒÅgiya", "sotƒÅpanna",
                "sakadƒÅgƒÅmi", "anƒÅgƒÅmi", "arahant", "sekha", "asekha", "puthujjana",
                "ariyapuggala", "sappurisa", "asappurisa", "kalyƒÅ·πáamitra", "pƒÅpamitra",
                "dhammadhara", "vinayadhara", "mƒÅtikƒÅdhara", "dhammakathika",
                "pa·π≠ibhƒÅnavant", "pa·π≠isambhidƒÅpa·π≠isambhida", "catuppa·π≠isambhidƒÅ",
                "attha-pa·π≠isambhidƒÅ", "dhamma-pa·π≠isambhidƒÅ", "nirutti-pa·π≠isambhidƒÅ",
                "pa·π≠ibhƒÅna-pa·π≠isambhidƒÅ", "pubbenivasƒÅnussati", "dibbacakkhu",
                "ƒÅsavakkhaya", "chalabhi√±√±ƒÅ", "a·π≠·π≠hasamƒÅpatti", "navasamƒÅpatti",
                "anupubbanirodha", "anupubbasamƒÅpatti", "nirodhasamƒÅpatti",
                "sa√±√±ƒÅvedayitanirodha", "animittƒÅ", "appa·πáihitƒÅ", "su√±√±atƒÅ",
                "vimokkhƒÅ", "atikara·πáƒ´ya", "anatikara·πáƒ´ya", "vikkhambhana",
                "tada·πÖga", "samuccheda", "pa·π≠ippassaddhi", "nissara·πáa",
                "dukkha-nissara·πáa", "jƒÅti-nissara·πáa", "jarƒÅ-nissara·πáa",
                "byƒÅdhi-nissara·πáa", "mara·πáa-nissara·πáa", "soka-nissara·πáa",
                "parideva-nissara·πáa", "upƒÅyƒÅsa-nissara·πáa", "domanassa-nissara·πáa",
                "upƒÅdƒÅna-nissara·πáa", "bhava-nissara·πáa", "kamma-nissara·πáa",
                "kilesa-nissara·πáa", "ƒÅsava-nissara·πáa", "sa·πÉsƒÅra-nissara·πáa",
            ],
            
            "ethics": [
                # Ethical and moral terms (80+ items)
                "sƒ´la", "cƒÅritta", "vƒÅritta", "dhuta·πÖga", "ƒÅpattivu·π≠·π≠hƒÅna",
                "adhisƒ´la", "adhicitta", "adhipa√±√±ƒÅ", "sammƒÅ", "micchƒÅ",
                "sammƒÅƒÅjƒ´va", "micchƒÅƒÅjƒ´va", "ƒÅjƒ´va", "ƒÅjƒ´vapƒÅrisuddhi",
                "kƒÅya-duccarita", "vacƒ´-duccarita", "mano-duccarita",
                "kƒÅya-sucarita", "vacƒ´-sucarita", "mano-sucarita", "pƒÅ·πáƒÅtipƒÅta",
                "adinnƒÅdƒÅna", "kƒÅmesu-micchƒÅcƒÅra", "musƒÅvƒÅda", "pisu·πáƒÅvƒÅcƒÅ",
                "pharusƒÅvƒÅcƒÅ", "samphappalƒÅpa", "abhijjhƒÅ", "byƒÅpƒÅda", "micchƒÅdi·π≠·π≠hi",
                "pƒÅ·πáƒÅtipƒÅtƒÅ-verama·πáƒ´", "adinnƒÅdƒÅnƒÅ-verama·πáƒ´", "kƒÅmesu-micchƒÅcƒÅrƒÅ-verama·πáƒ´",
                "musƒÅvƒÅdƒÅ-verama·πáƒ´", "surƒÅmeraya-majjapamƒÅda·π≠·π≠hƒÅnƒÅ-verama·πáƒ´",
                "vikƒÅlabhojanƒÅ-verama·πáƒ´", "naccagƒ´ta-vƒÅdita-vis≈´kadassanƒÅ-verama·πáƒ´",
                "mƒÅlƒÅgandha-vilepana-dhƒÅra·πáa-ma·πá·∏çana-vibh≈´sana·π≠·π≠hƒÅnƒÅ-verama·πáƒ´",
                "uccƒÅsayana-mahƒÅsayanƒÅ-verama·πáƒ´", "jƒÅtar≈´parajata-pa·π≠iggaha·πáƒÅ-verama·πáƒ´",
                "a·π≠·π≠ha·πÖgasamannƒÅgata-uposatha", "dasa-kusala-kammapatha",
                "dasa-akusala-kammapatha", "kamma", "kammapatha", "cetanƒÅ",
                "hetu", "m≈´la", "lobha-m≈´la", "dosa-m≈´la", "moha-m≈´la",
                "alobha-m≈´la", "adosa-m≈´la", "amoha-m≈´la", "dakkhi·πáa", "dƒÅna",
                "cƒÅga", "muditƒÅ", "karu·πáƒÅ", "mettƒÅ", "upekkhƒÅ", "brahmavihƒÅra",
                "appama√±√±ƒÅ", "pattidƒÅna", "pu√±√±akkhaya", "pu√±√±akiriya", "pu√±√±abhƒÅgiya",
                "niraya-gƒÅmƒ´", "tiracchƒÅna-gƒÅmƒ´", "peta-gƒÅmƒ´", "manussa-gƒÅmƒ´",
                "sagga-gƒÅmƒ´", "moksha-gƒÅmƒ´", "nibbƒÅna-gƒÅmƒ´", "khippƒÅbhi√±√±ƒÅ",
                "dantabh≈´mi", "sukhavihƒÅra", "ƒÅramma·πáa", "kamma·π≠·π≠hƒÅna", "gotra-bh≈´",
                "ariyava·πÉsa", "santu·π≠·π≠hi", "appiccha", "sallekhƒÅ", "ƒÅraddhavƒ´riya",
                "uttƒÅna", "gƒÅrava", "hirƒ´", "ottappa", "lajjƒ´", "kukkucca",
                "ahirikƒÅ", "anottappa", "sƒÅrajja", "visƒÅrada", "khanti",
                "sorƒÅcca", "sakhilyƒÅ", "dovacassatƒÅ", "sovacassatƒÅ", "pƒÅpamitra",
                "kalyƒÅ·πáamitra", "ƒÅpatti", "anƒÅpatti", "vƒ´tikkama", "ajjhƒÅcƒÅra",
                "dukka·π≠a", "dubbhƒÅsita", "thullaccaya", "pƒÅcittiya", "pƒÅ·π≠idesanƒ´ya",
                "dukka·π≠a-ƒÅpatti", "dubbhƒÅsita-ƒÅpatti", "thullaccaya-ƒÅpatti",
                "pƒÅcittiya-ƒÅpatti", "pƒÅ·π≠idesanƒ´ya-ƒÅpatti", "sekhiya-ƒÅpatti",
                "sƒÅvasesa", "anavasesa", "ukkhitta", "anukkhitta", "vu·π≠·π≠hƒÅpita",
                "avu·π≠·π≠hƒÅpita", "pakatatta", "apakatatta", "suddhanta", "asuddhanta",
            ],
            
            "psychology": [
                # Mental states and psychology (100+ items)
                "citta", "manas", "vi√±√±ƒÅ·πáa", "cetana", "cetasika", "manasikƒÅra",
                "phassa", "vedanƒÅ", "sa√±√±ƒÅ", "vitakka", "vicƒÅra", "adhimokkha",
                "viriya", "pƒ´ti", "chanda", "ƒÅramma·πáa", "dvƒÅra", "vatthu",
                "pavatti", "bhava·πÖga", "ƒÅvajjana", "dassana", "savana",
                "ghƒÅyana", "sƒÅyana", "phusana", "vijƒÅnana", "javana",
                "tadƒÅlambana", "vo·π≠·π≠habbana", "nƒÅmagotra", "r≈´pagotra",
                "kƒÅmagotra", "r≈´pagotra", "ar≈´pagotra", "lokuttaragotra",
                "cittuppƒÅda", "citta·π≠·π≠hiti", "cittabha·πÖga", "kha·πáika",
                "kha·πáattaya", "uppƒÅdakha·πáa", "·π≠hitikha·πáa", "bha·πÖgakha·πáa",
                "parinata", "jarƒÅ", "aniccatƒÅ", "kha·πáikaniccatƒÅ", "santatinicca",
                "cittakalƒÅpa", "r≈´pakalƒÅpa", "nƒÅmakalƒÅpa", "cittar≈´pa",
                "hadaya-vatthu", "cakkhuvatthu", "sotavatthu", "ghƒÅnavatthu",
                "jivhƒÅvatthu", "kƒÅyavatthu", "itthivatthu", "purisavatthu",
                "jƒ´vitavatthu", "cittaja", "kammaja", "utuja", "ƒÅhƒÅraja",
                "kƒÅyapassaddhi", "cittapassaddhi", "kƒÅyalahutƒÅ", "cittalahutƒÅ",
                "kƒÅyamudutƒÅ", "cittamudutƒÅ", "kƒÅyakamma√±√±atƒÅ", "cittakamma√±√±atƒÅ",
                "kƒÅyapƒÅgu√±√±atƒÅ", "cittapƒÅgu√±√±atƒÅ", "kƒÅyaujukatƒÅ", "cittaujukatƒÅ",
                "sammƒÅsati", "micchƒÅsati", "sati", "asati", "mu·π≠·π≠hasati",
                "upa·π≠·π≠hitasati", "asampaja√±√±ƒÅ", "sampaja√±√±ƒÅ", "saddhindriya",
                "saddhƒÅbala", "viriyindriya", "viriyabala", "satindriya",
                "satibala", "samƒÅdhindriya", "samƒÅdhibala", "pa√±√±indriya",
                "pa√±√±ƒÅbala", "jƒ´vitindriya", "manindriya", "dukkhaindriya",
                "domanassindriya", "sukhindriya", "somanassindriya", "upekkhindriya",
                "sotƒÅpattimagga", "sotƒÅpattiphala", "sakadƒÅgƒÅmimagga", "sakadƒÅgƒÅmiphala",
                "anƒÅgƒÅmimagga", "anƒÅgƒÅmiphala", "arahattamagga", "arahattaphala",
                "maggacitta", "phalacitta", "kriyƒÅcitta", "vipƒÅkacitta",
                "kƒÅmƒÅvacaracitta", "r≈´pƒÅvacaracitta", "ar≈´pƒÅvacaracitta",
                "lokuttaracitta", "akusalacetasika", "kusalacetasika",
                "abyƒÅkatacetasika", "sabbacittasƒÅdhƒÅra·πáa", "paki·πá·πáaka",
                "akusalasƒÅdhƒÅra·πáa", "sobhana", "virati", "appama√±√±ƒÅ",
                "pa√±√±indriya", "sammatta", "tatramajjhattatƒÅ", "kƒÅyapassaddhi",
                "cittapassaddhi", "kƒÅyalahutƒÅ", "cittalahutƒÅ", "kƒÅyamudutƒÅ",
                "cittamudutƒÅ", "kƒÅyakamma√±√±atƒÅ", "cittakamma√±√±atƒÅ", "kƒÅyapƒÅgu√±√±atƒÅ",
                "cittapƒÅgu√±√±atƒÅ", "kƒÅyaujukatƒÅ", "cittaujukatƒÅ", "sammƒÅvƒÅcƒÅ",
                "sammƒÅkammanta", "sammƒÅƒÅjƒ´va", "karu·πáƒÅ", "muditƒÅ", "sammƒÅ√±ƒÅ·πáa",
                "sammƒÅvimutti", "√±ƒÅ·πáadassana", "vimutti", "pa√±√±ƒÅvimutti",
                "cetovimutti", "ubhatobhƒÅgavimutti", "pa√±√±ƒÅvimutta", "cetovimutta",
                "ubhatobhƒÅgavimutta", "kƒÅyasakkhƒ´", "di·π≠·π≠hippatta", "saddhƒÅvimutta",
            ]
        }
    
    def _initialize_phrasal_expressions(self) -> Dict[str, str]:
        """Comprehensive Pali phrasal expressions and idioms"""
        return {
            # Greetings and salutations
            "katha·πÉ-bhaddantiko": "how are you, venerable sir?",
            "kacci-bhante-khamanƒ´ya·πÉ": "I hope, sir, it is agreeable?",
            "sukhƒ´-hotu": "may you be happy",
            "sukhƒ´-hontu": "may they be happy",
            "ƒÅrogyena-sampanno": "endowed with health",
            "di·π≠·π≠ha-dhamme-sukha·πÉ": "happiness in this life",
            "samparƒÅye-sukha·πÉ": "happiness in the next life",
            "katame-ca-bhante": "and what, sir?",
            "ki·πÉ-ma√±√±ati-bhante": "what do you think, sir?",
            "sƒÅdhu-bhante": "good, sir!",
            "sƒÅdhu-sƒÅdhu": "well done! well done!",
            "eva·πÉ-bhante": "yes, sir",
            "ƒÅma-bhante": "yes, sir",
            "na-h-eta·πÉ-bhante": "no, sir, it is not so",
            
            # Religious formulas
            "buddha·πÉ-sara·πáa·πÉ-gacchƒÅmi": "I go for refuge to the Buddha",
            "dhamma·πÉ-sara·πáa·πÉ-gacchƒÅmi": "I go for refuge to the Dhamma",
            "sa·πÖgha·πÉ-sara·πáa·πÉ-gacchƒÅmi": "I go for refuge to the Sangha",
            "dutiyam-pi-buddha·πÉ-sara·πáa·πÉ-gacchƒÅmi": "for the second time, I go for refuge to the Buddha",
            "tatiyam-pi-buddha·πÉ-sara·πáa·πÉ-gacchƒÅmi": "for the third time, I go for refuge to the Buddha",
            "namo-tassa-bhagavato-arahato-sammƒÅsambuddhassa": "homage to the Blessed One, the Worthy One, the Perfectly Enlightened One",
            "ye-dhammƒÅ-hetuppabhavƒÅ": "those phenomena that arise from a cause",
            "tesa·πÉ-hetu·πÉ-tathƒÅgato-ƒÅha": "the Tathagata has told the cause of them",
            "tesa√±-ca-yo-nirodho": "and their cessation too",
            "eva·πÉvƒÅdƒ´-mahƒÅsama·πáo": "thus speaks the great ascetic",
            "svƒÅkkhƒÅto-bhagavatƒÅ-dhammo": "well-proclaimed by the Blessed One is the Dhamma",
            "sandi·π≠·π≠hiko-akƒÅliko": "visible here and now, timeless",
            "ehipassiko-opaneyyiko": "inviting investigation, leading onwards",
            "paccatta·πÉ-veditabbo-vi√±√±≈´hi": "to be realized by the wise for themselves",
            "supa·π≠ipanno-bhagavato-sƒÅvakasa·πÖgho": "the Sangha of the Blessed One's disciples has practiced well",
            "ujupa·π≠ipanno-bhagavato-sƒÅvakasa·πÖgho": "the Sangha of the Blessed One's disciples has practiced uprightly",
            "√±ƒÅyapa·π≠ipanno-bhagavato-sƒÅvakasa·πÖgho": "the Sangha of the Blessed One's disciples has practiced insightfully",
            "sƒÅmƒ´cipa·π≠ipanno-bhagavato-sƒÅvakasa·πÖgho": "the Sangha of the Blessed One's disciples has practiced properly",
            
            # Teaching expressions
            "dhamma-cakkappavattana": "turning the wheel of Dhamma",
            "abhisamaya-samaya": "the time of penetration",
            "ariya-a·π≠·π≠ha·πÖgika-magga": "the Noble Eightfold Path",
            "cattƒÅri-ariya-saccƒÅni": "the Four Noble Truths",
            "ida·πÉ-dukkha·πÉ-ariya-sacca·πÉ": "this is the noble truth of suffering",
            "aya·πÉ-dukkha-samudayo-ariya-sacca·πÉ": "this is the noble truth of the origin of suffering",
            "aya·πÉ-dukkha-nirodho-ariya-sacca·πÉ": "this is the noble truth of the cessation of suffering",
            "aya·πÉ-dukkha-nirodha-gƒÅminƒ´-pa·π≠ipadƒÅ-ariya-sacca·πÉ": "this is the noble truth of the path leading to the cessation of suffering",
            "sabba·πÉ-dukkha·πÉ": "all is suffering",
            "sabbe-sa·πÖkhƒÅrƒÅ-aniccƒÅ": "all conditioned things are impermanent",
            "sabbe-dhammƒÅ-anattƒÅ": "all phenomena are without self",
            "nibbƒÅna·πÉ-parama·πÉ-sukha·πÉ": "Nibbana is the highest happiness",
            "appamƒÅdo-amatapada·πÉ": "mindfulness is the deathless state",
            "pamƒÅdo-maccuno-pada·πÉ": "negligence is the path of death",
            "appamattƒÅ-na-mƒ´yanti": "the mindful do not die",
            "ye-pamattƒÅ-yathƒÅ-matƒÅ": "the negligent are as if dead",
            
            # Monastic expressions
            "uposatha-kamma": "Uposatha ceremony",
            "pavƒÅra·πáƒÅ-kamma": "Pavarana ceremony",
            "kathina-kamma": "Kathina ceremony",
            "sa·πÖgha-kamma": "Sangha procedures",
            "kamma-vƒÅcƒÅ": "formal announcement",
            "√±atti-dutiya-kamma": "motion with one proclamation",
            "√±atti-catuttha-kamma": "motion with three proclamations",
            "yƒÅvatikƒÅ-bhikkh≈´": "all the monks who",
            "kaccit-te-bhante-parisuddhƒÅ": "I hope, venerable sir, they are pure?",
            "parisuddho-aha·πÉ-bhante": "I am pure, venerable sir",
            "imasmi·πÉ-nidƒÅne": "in this connection",
            "tena-vuccati": "therefore it is said",
            
            # Philosophical expressions
            "idappaccayatƒÅ": "conditionality",
            "imasmi·πÉ-sati-ida·πÉ-hoti": "when this exists, that comes to be",
            "imass-uppƒÅdƒÅ-ida·πÉ-uppajjati": "from the arising of this, that arises",
            "imasmi·πÉ-asati-ida·πÉ-na-hoti": "when this does not exist, that does not come to be",
            "imassa-nirodhƒÅ-ida·πÉ-nirujjhati": "from the cessation of this, that ceases",
            "avijjƒÅ-paccayƒÅ-sa·πÖkhƒÅrƒÅ": "with ignorance as condition, formations",
            "sa·πÖkhƒÅra-paccayƒÅ-vi√±√±ƒÅ·πáa·πÉ": "with formations as condition, consciousness",
            "vi√±√±ƒÅ·πáa-paccayƒÅ-nƒÅmar≈´pa·πÉ": "with consciousness as condition, name-and-form",
            "nƒÅmar≈´pa-paccayƒÅ-sa·∏∑ƒÅyatana·πÉ": "with name-and-form as condition, the six sense bases",
            "sa·∏∑ƒÅyatana-paccayƒÅ-phasso": "with the six sense bases as condition, contact",
            "phassa-paccayƒÅ-vedanƒÅ": "with contact as condition, feeling",
            "vedanƒÅ-paccayƒÅ-ta·πáhƒÅ": "with feeling as condition, craving",
            "ta·πáhƒÅ-paccayƒÅ-upƒÅdƒÅna·πÉ": "with craving as condition, clinging",
            "upƒÅdƒÅna-paccayƒÅ-bhavo": "with clinging as condition, existence",
            "bhava-paccayƒÅ-jƒÅti": "with existence as condition, birth",
            "jƒÅti-paccayƒÅ-jarƒÅmara·πáa·πÉ": "with birth as condition, aging and death",
            
            # Meditation instructions
            "ƒÅnƒÅpƒÅnasati-kamma·π≠·π≠hƒÅna·πÉ": "mindfulness of breathing meditation",
            "kƒÅyagatƒÅsati-kamma·π≠·π≠hƒÅna·πÉ": "mindfulness of the body meditation",
            "cattƒÅro-satipa·π≠·π≠hƒÅnƒÅ": "the four foundations of mindfulness",
            "kƒÅye-kƒÅyƒÅnupassanƒÅ": "contemplation of the body in the body",
            "vedanƒÅsu-vedanƒÅnupassanƒÅ": "contemplation of feelings in feelings",
            "citte-cittƒÅnupassanƒÅ": "contemplation of mind in mind",
            "dhammesu-dhammƒÅnupassanƒÅ": "contemplation of mind-objects in mind-objects",
            "satova-assasati": "mindfully he breathes in",
            "satova-passasati": "mindfully he breathes out",
            "dƒ´gha·πÉ-vƒÅ-assasanto": "breathing in long",
            "dƒ´gha·πÉ-vƒÅ-passasanto": "breathing out long",
            "rassa·πÉ-vƒÅ-assasanto": "breathing in short",
            "rassa·πÉ-vƒÅ-passasanto": "breathing out short",
            "sabbakƒÅyapa·π≠isa·πÉvedƒ´": "experiencing the whole body",
            "passambhaya·πÉ-kƒÅyasa·πÖkhƒÅra·πÉ": "calming bodily fabrication",
            
            # Ethical expressions
            "pƒÅ·πáƒÅtipƒÅtƒÅ-verama·πáƒ´": "abstaining from killing living beings",
            "adinnƒÅdƒÅnƒÅ-verama·πáƒ´": "abstaining from taking what is not given",
            "kƒÅmesu-micchƒÅcƒÅrƒÅ-verama·πáƒ´": "abstaining from sexual misconduct",
            "musƒÅvƒÅdƒÅ-verama·πáƒ´": "abstaining from false speech",
            "surƒÅmeraya-majjapamƒÅda·π≠·π≠hƒÅnƒÅ-verama·πáƒ´": "abstaining from intoxicants",
            "mettƒÅya-cittena": "with a mind of loving-kindness",
            "karu·πáƒÅya-cittena": "with a mind of compassion",
            "muditƒÅya-cittena": "with a mind of appreciative joy",
            "upekkhƒÅya-cittena": "with a mind of equanimity",
            "sabbƒÅ-disƒÅ-pharitvƒÅ": "having pervaded all directions",
            "vipula·πÉ-mahagata·πÉ": "abundant, exalted",
            "appamƒÅ·πáa·πÉ-avera·πÉ": "immeasurable, without hostility",
            "abyƒÅpajjha·πÉ-citta·πÉ": "without ill-will mind",
            "bhƒÅveti": "he develops",
            
            # Canonical phrases
            "eva·πÉ-me-suta·πÉ": "thus have I heard",
            "eka·πÉ-samaya·πÉ": "on one occasion",
            "bhagavƒÅ-viharati": "the Blessed One was staying",
            "sƒÅvatthiya·πÉ-jetavane": "at Savatthi in Jeta's Grove",
            "anƒÅthapi·πá·∏çikassa-ƒÅrƒÅme": "in Anathapindika's monastery",
            "atha-kho": "then",
            "tena-samayena": "at that time",
            "assosi-kho": "he heard",
            "yena-bhagavƒÅ-tenupasa·πÖkami": "he approached the Blessed One",
            "upasa·πÖkamitvƒÅ-bhagavanta·πÉ-abhivƒÅdetvƒÅ": "having approached and paid respect to the Blessed One",
            "ekamanta·πÉ-nisƒ´di": "he sat to one side",
            "ekamanta·πÉ-nisinno-kho": "sitting to one side",
            "bhagavanta·πÉ-etad-avoca": "he said this to the Blessed One",
            "sƒÅdhu-bhante": "good, venerable sir",
            "bhƒÅsita·πÉ-abhinanditvƒÅ": "having delighted in the statement",
            "anumoditvƒÅ": "having approved",
            "u·π≠·π≠hƒÅyƒÅsanƒÅ": "rising from his seat",
            "bhagavanta·πÉ-abhivƒÅdetvƒÅ": "having paid respect to the Blessed One",
            "padakkhi·πáa·πÉ-katvƒÅ": "having gone around to the right",
            "pakkƒÅmi": "he departed",
            "ida·πÉ-vatvƒÅ": "having said this",
            "sugato-ahosi": "the well-gone one became",
            "idam-avoca-bhagavƒÅ": "this said the Blessed One",
            "attamanƒÅ-te-bhikkh≈´": "satisfied, those monks",
            "bhagavato-bhƒÅsita·πÉ-abhinandu·πÉ": "delighted in the Blessed One's words",
            
            # Completion formulas
            "iti-kho-paneta·πÉ-vuccati": "thus indeed this is called",
            "tasmƒÅtiha": "therefore here",
            "tenƒÅha-bhagavƒÅ": "therefore the Blessed One said",
            "ya·πÉ-ta·πÉ-sammƒÅ-vadamƒÅno-vadeyya": "one speaking rightly would say",
            "iti-heta·πÉ": "thus this",
            "dakkhi·πáeyyo": "worthy of offerings",
            "ƒÅhuneyyo": "worthy of hospitality",
            "pƒÅhuneyyo": "worthy of gifts",
            "a√±jalikara·πáƒ´yo": "worthy of reverential salutation",
            "anuttara·πÉ-pu√±√±akkhetta·πÉ": "unsurpassed field of merit",
            "lokassa": "for the world",
            
            # Aspirational phrases
            "iminƒÅ-pu√±√±akammena": "by this meritorious deed",
            "upajjhƒÅyƒÅ-gu·πáa·πÉ": "may the virtue of teachers",
            "sabbesattƒÅna·πÉ": "of all beings",
            "hotu": "may there be",
            "sukhitƒÅ-hontu": "may they be happy",
            "niddukkha-hontu": "may they be free from suffering",
            "avera-hontu": "may they be free from enmity",
            "abyƒÅpajjƒÅ-hontu": "may they be free from ill-will",
            "anƒ´ghƒÅ-hontu": "may they be free from trouble",
            "sukhƒ´-attƒÅna·πÉ-pariharantu": "may they look after themselves happily",
            "sabbe-sattƒÅ-sadƒÅ-hontu": "may all beings always be",
            "averƒÅ-sukhajƒ´vino": "free from enmity and living happily",
            "kata·πÉ-pu√±√±aphala·πÉ": "the fruit of the merit done",
            "mayha·πÉ-sabbe-upakƒÅrahontu": "may all be helpful to me",
            "ye-santƒÅne-hinƒÅ-sattƒÅ": "those beings who are inferior in the stream of existence",
            "te-sabbe-tƒÅrayƒÅmyaha·πÉ": "I shall help them all across",
            
            # Protective formulas
            "jayanto-bodhiyƒÅ-m≈´le": "victorious at the foot of the Bodhi tree",
            "sakyƒÅna·πÉ-nandiva·∏ç·∏çhano": "increasing the joy of the Sakyans",
            "evam-ƒÅdigu·πáa-dharo": "possessing such virtues and so forth",
            "buddho-me-rakkhatu": "may the Buddha protect me",
            "dhammo-me-rakkhatu": "may the Dhamma protect me",
            "sa·πÖgho-me-rakkhatu": "may the Sangha protect me",
            "buddhƒÅdhi·π≠·π≠hitena": "blessed by the Buddha",
            "dhammƒÅdhi·π≠·π≠hitena": "blessed by the Dhamma",
            "sa·πÖghƒÅdhi·π≠·π≠hitena": "blessed by the Sangha",
            "buddharatanena": "by the Buddha-jewel",
            "dhammaratanena": "by the Dhamma-jewel",
            "sa·πÖgharatanena": "by the Sangha-jewel",
            "tiratanena": "by the Triple Gem",
            "sƒÅdhu-sƒÅdhu-sƒÅdhu": "well done! well done! well done!",
        }
    
    def _initialize_liturgical_formulas(self) -> Dict[str, str]:
        """Buddhist liturgical and ceremonial formulas"""
        return {
            # Triple Gem formulas
            "buddha-vandanƒÅ": "veneration to the Buddha",
            "dhamma-vandanƒÅ": "veneration to the Dhamma",
            "sa·πÖgha-vandanƒÅ": "veneration to the Sangha",
            "ratanattaya-vandanƒÅ": "veneration to the Triple Gem",
            "buddha-gu·πáa-gƒÅthƒÅ": "verses on Buddha's qualities",
            "dhamma-gu·πáa-gƒÅthƒÅ": "verses on Dhamma's qualities",
            "sa·πÖgha-gu·πáa-gƒÅthƒÅ": "verses on Sangha's qualities",
            
            # Paritta (protective chants)
            "ratana-sutta-paritta": "Ratana Sutta protection",
            "kara·πáƒ´ya-mettƒÅ-sutta-paritta": "Karaniya Metta Sutta protection",
            "khandha-paritta": "aggregate protection",
            "mora-paritta": "peacock protection",
            "va·π≠·π≠a-paritta": "quail protection",
            "dhajagga-paritta": "banner protection",
            "ƒÅ·π≠ƒÅnƒÅ·π≠iya-paritta": "Atanatiya protection",
            "a·πÖgulimƒÅla-paritta": "Angulimala protection",
            "bojjha·πÖga-paritta": "enlightenment factor protection",
            "pubba·πáha-paritta": "morning protection",
            "sƒÅyanha-paritta": "evening protection",
            "rattibhƒÅga-paritta": "night protection",
            "caturƒÅrakkhƒÅ-paritta": "four protections",
            "pa√±cƒÅrakkhƒÅ-paritta": "five protections",
            "sattƒÅrakkhƒÅ-paritta": "seven protections",
            "navƒÅrakkhƒÅ-paritta": "nine protections",
            "mahƒÅ-paritta": "great protection",
            
            # Blessing formulas
            "bhavatu-sabba-ma·πÖgala·πÉ": "may there be all blessings",
            "rakkhantu-sabba-devatƒÅ": "may all deities protect",
            "sadƒÅ-sotthƒ´-bhavantu-te": "may you always be safe",
            "nidukkho-bhava": "be free from suffering",
            "yathƒÅ-icchita·πÉ": "as desired",
            "tathƒÅ-bhavatu": "so may it be",
            "sukhƒ´-homi": "may I be happy",
            "niddukkho-homi": "may I be free from suffering",
            "avero-homi": "may I be free from enmity",
            "abyƒÅpajjo-homi": "may I be free from ill-will",
            "anƒ´gho-homi": "may I be free from trouble",
            "sukhƒ´-attƒÅna·πÉ-pariharƒÅmi": "may I look after myself happily",
            "sabba-sattƒÅ-sukhƒ´-hontu": "may all beings be happy",
            "sabba-sattƒÅ-averƒÅ-hontu": "may all beings be free from enmity",
            "sabba-sattƒÅ-abyƒÅpajjƒÅ-hontu": "may all beings be free from ill-will",
            "sabba-sattƒÅ-anƒ´ghƒÅ-hontu": "may all beings be free from trouble",
            "sabba-sattƒÅ-sukhƒ´-attƒÅna·πÉ-pariharantu": "may all beings look after themselves happily",
            
            # Merit dedication
            "pu√±√±a·πÉ-pasƒÅdayƒÅmi": "I dedicate merit",
            "ida·πÉ-me-pu√±√±a·πÉ": "this merit of mine",
            "ƒÅsavakkhayƒÅvaha·πÉ-hotu": "may it lead to the destruction of taints",
            "ida·πÉ-me-pu√±√±a·πÉ-nibbƒÅnassa-paccayo-hotu": "may this merit of mine be a condition for Nibbana",
            "mama-pu√±√±abhƒÅga·πÉ": "my share of merit",
            "sabba-sattƒÅna·πÉ-bhƒÅjemi": "I share with all beings",
            "te-sabbe-me-sama·πÉ": "may they all equally with me",
            "pu√±√±abhƒÅga·πÉ-labhantu": "receive a share of merit",
            "sƒÅdhu-anumodanƒÅ": "good appreciation",
            "sƒÅdhu-sƒÅdhu-anumodƒÅmi": "I appreciate well, well",
            
            # Forgiveness and confession
            "kƒÅyena-vƒÅcƒÅya": "by body and speech",
            "manasƒÅ-vƒÅ": "or by mind",
            "buddhe-kukamma·πÉ": "wrong action towards the Buddha",
            "pakata·πÉ-mayƒÅ": "done by me",
            "buddho-pa·π≠igga·πáhƒÅtu": "may the Buddha accept",
            "accaya·πÉ-me-bhante": "my transgression, venerable sir",
            "khamatu-me-bhante": "forgive me, venerable sir",
            "bhagavƒÅ-khamatu": "may the Blessed One forgive",
            "desetu-me-bhante": "teach me, venerable sir",
            "ovƒÅda·πÉ-anusi·π≠·π≠hi·πÉ": "advice and instruction",
            "karomase-bhante": "we do, venerable sir",
            
            # Ceremony formulas
            "uposatha-sƒ´la": "Uposatha precepts",
            "a·π≠·π≠ha·πÖga-samannƒÅgata·πÉ": "endowed with eight factors",
            "ima√±-ca-ratti·πÉ": "this night",
            "ima√±-ca-divasa·πÉ": "this day",
            "sammƒÅ-deva": "rightly indeed",
            "ajja-mayƒÅ": "today by me",
            "uposatha·πÉ": "Uposatha",
            "kƒÅretabba·πÉ": "should be done",
            "uposathassa": "of Uposatha",
            "pƒÅrip≈´riyƒÅ": "for the completion",
            "tisara·πáa-gamana·πÉ": "going to the Three Refuges",
            "pa√±ca-sƒ´la-samƒÅdƒÅna·πÉ": "undertaking the Five Precepts",
            "a·π≠·π≠ha-sƒ´la-samƒÅdƒÅna·πÉ": "undertaking the Eight Precepts",
            "dasa-sƒ´la-samƒÅdƒÅna·πÉ": "undertaking the Ten Precepts",
            
            # Teaching formulas
            "dhamma-desanƒÅ": "Dhamma teaching",
            "dhamma-kathƒÅ": "Dhamma talk",
            "dhamma-sava·πáa": "hearing the Dhamma",
            "suttanta-desanƒÅ": "discourse teaching",
            "geyya-desanƒÅ": "verse teaching",
            "veyyƒÅkara·πáa-desanƒÅ": "explanatory teaching",
            "ovƒÅda-anusƒÅsanƒ´": "advice and instruction",
            "dhamma-cakka-pavattana": "turning the wheel of Dhamma",
            "pa·π≠hama-desanƒÅ": "first teaching",
            "majjhima-desanƒÅ": "middle teaching",
            "pacchima-desanƒÅ": "final teaching",
            "sƒÅsana-kicca": "teaching duty",
            "buddha-vacana": "word of the Buddha",
            "dhamma-vinaya": "Dhamma and Discipline",
            
            # Monastic formulas
            "pabbajjƒÅ-kamma": "going forth ceremony",
            "upasampadƒÅ-kamma": "full ordination ceremony",
            "nissaya-dƒÅna": "giving dependence",
            "nissaya-mutti": "release from dependence",
            "ovƒÅda-pƒÅ·π≠imokkha": "admonition of the Patimokkha",
            "pƒÅ·π≠imokkha-uddesaka": "reciter of the Patimokkha",
            "vinaya-kamma": "disciplinary procedure",
            "sa·πÖgha-kamma": "Sangha procedure",
            "uposatha-kamma": "Uposatha procedure",
            "pavƒÅra·πáƒÅ-kamma": "Pavarana procedure",
            "kathina-atthƒÅra": "spreading the Kathina",
            "kathina-uddhara·πáa": "lifting the Kathina",
            "cƒ´vara-kƒÅla": "robe season",
            "vassa-kƒÅla": "rains season",
            "hemanta-kƒÅla": "cool season",
            "gima-kƒÅla": "hot season",
        }
    
    def _initialize_proper_names(self) -> Dict[str, Dict[str, str]]:
        """Proper names with declension information"""
        return {
            # Buddha's names
            "Buddha": {"meaning": "Awakened One", "gender": "m", "declension": "a_masculine", "type": "title"},
            "Siddhattha": {"meaning": "one whose goal is accomplished", "gender": "m", "declension": "a_masculine", "type": "personal"},
            "Gotama": {"meaning": "best ox", "gender": "m", "declension": "a_masculine", "type": "clan"},
            "Bhagavant": {"meaning": "Blessed One", "gender": "m", "declension": "ant_masculine", "type": "title"},
            "TathƒÅgata": {"meaning": "Thus-gone One", "gender": "m", "declension": "a_masculine", "type": "title"},
            "SammƒÅsambuddha": {"meaning": "Perfectly Self-Enlightened One", "gender": "m", "declension": "a_masculine", "type": "title"},
            "Sugata": {"meaning": "Well-gone One", "gender": "m", "declension": "a_masculine", "type": "title"},
            "Lokavid≈´": {"meaning": "Knower of the World", "gender": "m", "declension": "u_masculine", "type": "title"},
            "AnuttarapurisadammasƒÅrathi": {"meaning": "Unsurpassed Leader of Persons to be Tamed", "gender": "m", "declension": "i_masculine", "type": "title"},
            "SatthƒÅdevamanussƒÅna·πÉ": {"meaning": "Teacher of Devas and Humans", "gender": "m", "declension": "ar_masculine", "type": "title"},
            
            # Places
            "Kapilavatthu": {"meaning": "city of Kapila", "gender": "n", "declension": "u_neuter", "type": "city"},
            "Lumbinƒ´": {"meaning": "Lumbini garden", "gender": "f", "declension": "ii_feminine", "type": "place"},
            "BuddhagayƒÅ": {"meaning": "Buddha's Gaya", "gender": "f", "declension": "aa_feminine", "type": "place"},
            "Isipatana": {"meaning": "place where sages land", "gender": "n", "declension": "a_neuter", "type": "place"},
            "MigadƒÅya": {"meaning": "deer park", "gender": "m", "declension": "a_masculine", "type": "place"},
            "BƒÅrƒÅ·πáasƒ´": {"meaning": "Varanasi", "gender": "f", "declension": "ii_feminine", "type": "city"},
            "SƒÅvatthƒ´": {"meaning": "Savatthi", "gender": "f", "declension": "ii_feminine", "type": "city"},
            "Jetavana": {"meaning": "Jeta's grove", "gender": "n", "declension": "a_neuter", "type": "monastery"},
            "AnƒÅthapi·πá·∏çikassa-ƒÅrƒÅma": {"meaning": "Anathapindika's monastery", "gender": "m", "declension": "a_masculine", "type": "monastery"},
            "PubbƒÅrƒÅma": {"meaning": "Eastern monastery", "gender": "m", "declension": "a_masculine", "type": "monastery"},
            "MigƒÅramƒÅtupƒÅsƒÅda": {"meaning": "Migara's mother's mansion", "gender": "m", "declension": "a_masculine", "type": "building"},
            "Gijjhak≈´·π≠a": {"meaning": "Vulture Peak", "gender": "m", "declension": "a_masculine", "type": "mountain"},
            "Ve·∏∑uvana": {"meaning": "Bamboo Grove", "gender": "n", "declension": "a_neuter", "type": "monastery"},
            "KalandakanivƒÅpa": {"meaning": "Squirrel's feeding place", "gender": "m", "declension": "a_masculine", "type": "place"},
            "RƒÅjagaha": {"meaning": "King's house", "gender": "n", "declension": "a_neuter", "type": "city"},
            "VesƒÅli": {"meaning": "Vesali", "gender": "f", "declension": "ii_feminine", "type": "city"},
            "MahƒÅvana": {"meaning": "Great Grove", "gender": "n", "declension": "a_neuter", "type": "place"},
            "K≈´·π≠ƒÅgƒÅrasƒÅlƒÅ": {"meaning": "Peaked Hall", "gender": "f", "declension": "aa_feminine", "type": "building"},
            "KusinƒÅrƒÅ": {"meaning": "Kusinara", "gender": "f", "declension": "aa_feminine", "type": "city"},
            "Upavattana": {"meaning": "Upavattana", "gender": "n", "declension": "a_neuter", "type": "place"},
            "SƒÅlavana": {"meaning": "Sala Grove", "gender": "n", "declension": "a_neuter", "type": "place"},
            
            # Important disciples
            "SƒÅriputta": {"meaning": "son of Sari", "gender": "m", "declension": "a_masculine", "type": "monk"},
            "MoggallƒÅna": {"meaning": "descendant of Moggalla", "gender": "m", "declension": "a_masculine", "type": "monk"},
            "MahƒÅkassapa": {"meaning": "Great Kassapa", "gender": "m", "declension": "a_masculine", "type": "monk"},
            "ƒÄnanda": {"meaning": "joy", "gender": "m", "declension": "a_masculine", "type": "monk"},
            "UpƒÅli": {"meaning": "protector", "gender": "m", "declension": "i_masculine", "type": "monk"},
            "Anuruddha": {"meaning": "not obstructed", "gender": "m", "declension": "a_masculine", "type": "monk"},
            "RƒÅhula": {"meaning": "fetter", "gender": "m", "declension": "a_masculine", "type": "monk"},
            "Devadatta": {"meaning": "given by gods", "gender": "m", "declension": "a_masculine", "type": "monk"},
            "MahƒÅpajƒÅpatƒ´": {"meaning": "Great Pajapati", "gender": "f", "declension": "ii_feminine", "type": "nun"},
            "KhemƒÅ": {"meaning": "security", "gender": "f", "declension": "aa_feminine", "type": "nun"},
            "Uppalava·πá·πáƒÅ": {"meaning": "lotus-colored", "gender": "f", "declension": "aa_feminine", "type": "nun"},
            "BhaddakaccƒÅnƒÅ": {"meaning": "fortunate Kaccana", "gender": "f", "declension": "aa_feminine", "type": "nun"},
            "Pa·π≠ƒÅcƒÅrƒÅ": {"meaning": "one with a bowl", "gender": "f", "declension": "aa_feminine", "type": "nun"},
            "KisƒÅgotamƒ´": {"meaning": "lean Gotami", "gender": "f", "declension": "ii_feminine", "type": "nun"},
            
            # Kings and rulers
            "BimbisƒÅra": {"meaning": "moon's essence", "gender": "m", "declension": "a_masculine", "type": "king"},
            "AjƒÅtasattu": {"meaning": "enemy before birth", "gender": "m", "declension": "u_masculine", "type": "king"},
            "Pasenadi": {"meaning": "Pasenadi", "gender": "m", "declension": "i_masculine", "type": "king"},
            "Suddhodana": {"meaning": "pure rice", "gender": "m", "declension": "a_masculine", "type": "king"},
            "MahƒÅmƒÅyƒÅ": {"meaning": "Great Maya", "gender": "f", "declension": "aa_feminine", "type": "queen"},
            "YasodharƒÅ": {"meaning": "bearer of fame", "gender": "f", "declension": "aa_feminine", "type": "princess"},
            
            # Celestial beings
            "Sakka": {"meaning": "able one", "gender": "m", "declension": "a_masculine", "type": "deva"},
            "Indra": {"meaning": "lord", "gender": "m", "declension": "a_masculine", "type": "deva"},
            "BrahmƒÅ": {"meaning": "sacred utterance", "gender": "m", "declension": "a_masculine", "type": "brahma"},
            "Sahampati": {"meaning": "lord of the retinue", "gender": "m", "declension": "i_masculine", "type": "brahma"},
            "MƒÅra": {"meaning": "death", "gender": "m", "declension": "a_masculine", "type": "mara"},
            
            # Other important figures
            "Yasa": {"meaning": "fame", "gender": "m", "declension": "a_masculine", "type": "lay_disciple"},
            "AnƒÅthapi·πá·∏çika": {"meaning": "feeder of the destitute", "gender": "m", "declension": "a_masculine", "type": "lay_disciple"},
            "VisƒÅkhƒÅ": {"meaning": "Visakha", "gender": "f", "declension": "aa_feminine", "type": "lay_disciple"},
            "MigƒÅramƒÅtƒÅ": {"meaning": "Migara's mother", "gender": "f", "declension": "ar_feminine", "type": "lay_disciple"},
            "Jƒ´vaka": {"meaning": "life", "gender": "m", "declension": "a_masculine", "type": "physician"},
            "AmbapƒÅli": {"meaning": "mango keeper", "gender": "f", "declension": "ii_feminine", "type": "courtesan"},
            "A·πÖgulimƒÅla": {"meaning": "finger garland", "gender": "m", "declension": "a_masculine", "type": "former_bandit"},
            "Pukkusa": {"meaning": "Pukkusa", "gender": "m", "declension": "a_masculine", "type": "malla"},
            "Cunda": {"meaning": "Cunda", "gender": "m", "declension": "a_masculine", "type": "smith"},
        }
    
    def _initialize_complete_numerals(self) -> Dict[str, Dict[str, str]]:
        """Complete numeral system with all variants"""
        return {
            # Cardinals
            "eka": {"type": "cardinal", "value": 1, "meaning": "one", "gender": "all"},
            "dvi": {"type": "cardinal", "value": 2, "meaning": "two", "gender": "all"},
            "duve": {"type": "cardinal", "value": 2, "meaning": "two (feminine)", "gender": "f"},
            "ti": {"type": "cardinal", "value": 3, "meaning": "three", "gender": "all"},
            "tisso": {"type": "cardinal", "value": 3, "meaning": "three (feminine)", "gender": "f"},
            "catu": {"type": "cardinal", "value": 4, "meaning": "four", "gender": "all"},
            "catasso": {"type": "cardinal", "value": 4, "meaning": "four (feminine)", "gender": "f"},
            "pa√±ca": {"type": "cardinal", "value": 5, "meaning": "five", "gender": "all"},
            "cha": {"type": "cardinal", "value": 6, "meaning": "six", "gender": "all"},
            "satta": {"type": "cardinal", "value": 7, "meaning": "seven", "gender": "all"},
            "a·π≠·π≠ha": {"type": "cardinal", "value": 8, "meaning": "eight", "gender": "all"},
            "nava": {"type": "cardinal", "value": 9, "meaning": "nine", "gender": "all"},
            "dasa": {"type": "cardinal", "value": 10, "meaning": "ten", "gender": "all"},
            "ekƒÅdasa": {"type": "cardinal", "value": 11, "meaning": "eleven", "gender": "all"},
            "dvƒÅdasa": {"type": "cardinal", "value": 12, "meaning": "twelve", "gender": "all"},
            "terasa": {"type": "cardinal", "value": 13, "meaning": "thirteen", "gender": "all"},
            "cuddasa": {"type": "cardinal", "value": 14, "meaning": "fourteen", "gender": "all"},
            "pa·πá·πáarasa": {"type": "cardinal", "value": 15, "meaning": "fifteen", "gender": "all"},
            "so·∏∑asa": {"type": "cardinal", "value": 16, "meaning": "sixteen", "gender": "all"},
            "sattarasa": {"type": "cardinal", "value": 17, "meaning": "seventeen", "gender": "all"},
            "a·π≠·π≠hƒÅrasa": {"type": "cardinal", "value": 18, "meaning": "eighteen", "gender": "all"},
            "ek≈´navƒ´sati": {"type": "cardinal", "value": 19, "meaning": "nineteen", "gender": "all"},
            "vƒ´sati": {"type": "cardinal", "value": 20, "meaning": "twenty", "gender": "all"},
            "ekatƒ´sa": {"type": "cardinal", "value": 21, "meaning": "twenty-one", "gender": "all"},
            "dvƒÅtƒ´sa": {"type": "cardinal", "value": 22, "meaning": "twenty-two", "gender": "all"},
            "ti·πÉsati": {"type": "cardinal", "value": 30, "meaning": "thirty", "gender": "all"},
            "cattƒÅlƒ´sa": {"type": "cardinal", "value": 40, "meaning": "forty", "gender": "all"},
            "pa√±√±ƒÅsa": {"type": "cardinal", "value": 50, "meaning": "fifty", "gender": "all"},
            "sa·π≠·π≠hi": {"type": "cardinal", "value": 60, "meaning": "sixty", "gender": "all"},
            "sattati": {"type": "cardinal", "value": 70, "meaning": "seventy", "gender": "all"},
            "asƒ´ti": {"type": "cardinal", "value": 80, "meaning": "eighty", "gender": "all"},
            "navuti": {"type": "cardinal", "value": 90, "meaning": "ninety", "gender": "all"},
            "sata": {"type": "cardinal", "value": 100, "meaning": "hundred", "gender": "all"},
            "ekasata": {"type": "cardinal", "value": 101, "meaning": "one hundred one", "gender": "all"},
            "dvisata": {"type": "cardinal", "value": 200, "meaning": "two hundred", "gender": "all"},
            "tisata": {"type": "cardinal", "value": 300, "meaning": "three hundred", "gender": "all"},
            "catusata": {"type": "cardinal", "value": 400, "meaning": "four hundred", "gender": "all"},
            "pa√±casata": {"type": "cardinal", "value": 500, "meaning": "five hundred", "gender": "all"},
            "chasata": {"type": "cardinal", "value": 600, "meaning": "six hundred", "gender": "all"},
            "sattasata": {"type": "cardinal", "value": 700, "meaning": "seven hundred", "gender": "all"},
            "a·π≠·π≠hasata": {"type": "cardinal", "value": 800, "meaning": "eight hundred", "gender": "all"},
            "navasata": {"type": "cardinal", "value": 900, "meaning": "nine hundred", "gender": "all"},
            "sahassa": {"type": "cardinal", "value": 1000, "meaning": "thousand", "gender": "all"},
            "dasasahassa": {"type": "cardinal", "value": 10000, "meaning": "ten thousand", "gender": "all"},
            "satasahassa": {"type": "cardinal", "value": 100000, "meaning": "one hundred thousand", "gender": "all"},
            "lakkha": {"type": "cardinal", "value": 100000, "meaning": "lakh", "gender": "all"},
            "dasalakkha": {"type": "cardinal", "value": 1000000, "meaning": "ten lakh", "gender": "all"},
            "ko·π≠i": {"type": "cardinal", "value": 10000000, "meaning": "crore", "gender": "all"},
            "a·π≠·π≠ha-ko·π≠i": {"type": "cardinal", "value": 80000000, "meaning": "eight crores", "gender": "all"},
            "nahuta": {"type": "cardinal", "value": 1000000000, "meaning": "billion", "gender": "all"},
            "ninnahuta": {"type": "cardinal", "value": 10000000000, "meaning": "ten billion", "gender": "all"},
            "akkhobhinƒ´": {"type": "cardinal", "value": 100000000000, "meaning": "hundred billion", "gender": "all"},
            "bindu": {"type": "cardinal", "value": 1000000000000, "meaning": "trillion", "gender": "all"},
            "abbuda": {"type": "cardinal", "value": 10000000000000, "meaning": "ten trillion", "gender": "all"},
            "nirabbuda": {"type": "cardinal", "value": 100000000000000, "meaning": "hundred trillion", "gender": "all"},
            "ahaha": {"type": "cardinal", "value": 1000000000000000, "meaning": "quadrillion", "gender": "all"},
            "ababa": {"type": "cardinal", "value": 10000000000000000, "meaning": "ten quadrillion", "gender": "all"},
            "a·π≠a·π≠a": {"type": "cardinal", "value": 100000000000000000, "meaning": "hundred quadrillion", "gender": "all"},
            "sogandhika": {"type": "cardinal", "value": 1000000000000000000, "meaning": "quintillion", "gender": "all"},
            "uppala": {"type": "cardinal", "value": 10000000000000000000, "meaning": "ten quintillion", "gender": "all"},
            "kumuda": {"type": "cardinal", "value": 100000000000000000000, "meaning": "hundred quintillion", "gender": "all"},
            "pu·πá·∏çarƒ´ka": {"type": "cardinal", "value": 1000000000000000000000, "meaning": "sextillion", "gender": "all"},
            "paduma": {"type": "cardinal", "value": 10000000000000000000000, "meaning": "ten sextillion", "gender": "all"},
            "kathana": {"type": "cardinal", "value": 100000000000000000000000, "meaning": "hundred sextillion", "gender": "all"},
            "mahƒÅkathana": {"type": "cardinal", "value": 1000000000000000000000000, "meaning": "septillion", "gender": "all"},
            "asa·πÖkheyya": {"type": "cardinal", "value": "‚àû", "meaning": "incalculable", "gender": "all"},
            
            # Ordinals
            "pa·π≠hama": {"type": "ordinal", "value": 1, "meaning": "first", "gender": "all"},
            "dutiya": {"type": "ordinal", "value": 2, "meaning": "second", "gender": "all"},
            "tatiya": {"type": "ordinal", "value": 3, "meaning": "third", "gender": "all"},
            "catuttha": {"type": "ordinal", "value": 4, "meaning": "fourth", "gender": "all"},
            "pa√±cama": {"type": "ordinal", "value": 5, "meaning": "fifth", "gender": "all"},
            "cha·π≠·π≠ha": {"type": "ordinal", "value": 6, "meaning": "sixth", "gender": "all"},
            "sattama": {"type": "ordinal", "value": 7, "meaning": "seventh", "gender": "all"},
            "a·π≠·π≠hama": {"type": "ordinal", "value": 8, "meaning": "eighth", "gender": "all"},
            "navama": {"type": "ordinal", "value": 9, "meaning": "ninth", "gender": "all"},
            "dasama": {"type": "ordinal", "value": 10, "meaning": "tenth", "gender": "all"},
            "ekƒÅdasama": {"type": "ordinal", "value": 11, "meaning": "eleventh", "gender": "all"},
            "dvƒÅdasama": {"type": "ordinal", "value": 12, "meaning": "twelfth", "gender": "all"},
            "vƒ´satima": {"type": "ordinal", "value": 20, "meaning": "twentieth", "gender": "all"},
            "ti·πÉsatima": {"type": "ordinal", "value": 30, "meaning": "thirtieth", "gender": "all"},
            "satama": {"type": "ordinal", "value": 100, "meaning": "hundredth", "gender": "all"},
            "sahassama": {"type": "ordinal", "value": 1000, "meaning": "thousandth", "gender": "all"},
            "pacchima": {"type": "ordinal", "value": "last", "meaning": "last, final", "gender": "all"},
            "antima": {"type": "ordinal", "value": "last", "meaning": "last, final", "gender": "all"},
            
            # Multiplicatives
            "ekaka": {"type": "multiplicative", "value": 1, "meaning": "single, solitary", "gender": "all"},
            "dvika": {"type": "multiplicative", "value": 2, "meaning": "double, pair", "gender": "all"},
            "tika": {"type": "multiplicative", "value": 3, "meaning": "triple, triad", "gender": "all"},
            "catukka": {"type": "multiplicative", "value": 4, "meaning": "quadruple, tetrad", "gender": "all"},
            "pa√±caka": {"type": "multiplicative", "value": 5, "meaning": "fivefold, pentad", "gender": "all"},
            "chakka": {"type": "multiplicative", "value": 6, "meaning": "sixfold, hexad", "gender": "all"},
            "sattaka": {"type": "multiplicative", "value": 7, "meaning": "sevenfold", "gender": "all"},
            "a·π≠·π≠haka": {"type": "multiplicative", "value": 8, "meaning": "eightfold", "gender": "all"},
            "navaka": {"type": "multiplicative", "value": 9, "meaning": "ninefold", "gender": "all"},
            "dasaka": {"type": "multiplicative", "value": 10, "meaning": "tenfold", "gender": "all"},
            "sataka": {"type": "multiplicative", "value": 100, "meaning": "hundredfold", "gender": "all"},
            "sahassaka": {"type": "multiplicative", "value": 1000, "meaning": "thousandfold", "gender": "all"},
            
            # Distributives
            "ekeka": {"type": "distributive", "value": 1, "meaning": "one by one", "gender": "all"},
            "dvƒ´dvƒÅ": {"type": "distributive", "value": 2, "meaning": "two by two", "gender": "all"},
            "tayo-tayo": {"type": "distributive", "value": 3, "meaning": "three by three", "gender": "all"},
            "cattƒÅro-cattƒÅro": {"type": "distributive", "value": 4, "meaning": "four by four", "gender": "all"},
            "pa√±ca-pa√±ca": {"type": "distributive", "value": 5, "meaning": "five by five", "gender": "all"},
            "cha-cha": {"type": "distributive", "value": 6, "meaning": "six by six", "gender": "all"},
            "satta-satta": {"type": "distributive", "value": 7, "meaning": "seven by seven", "gender": "all"},
            "a·π≠·π≠ha-a·π≠·π≠ha": {"type": "distributive", "value": 8, "meaning": "eight by eight", "gender": "all"},
            "nava-nava": {"type": "distributive", "value": 9, "meaning": "nine by nine", "gender": "all"},
            "dasa-dasa": {"type": "distributive", "value": 10, "meaning": "ten by ten", "gender": "all"},
            
            # Fractionals
            "a·∏ç·∏çha": {"type": "fractional", "value": 0.5, "meaning": "half", "gender": "all"},
            "pƒÅda": {"type": "fractional", "value": 0.25, "meaning": "quarter", "gender": "all"},
            "tiya": {"type": "fractional", "value": 0.33, "meaning": "third", "gender": "all"},
            "catutthabhƒÅga": {"type": "fractional", "value": 0.25, "meaning": "fourth part", "gender": "all"},
            "pa√±camabhƒÅga": {"type": "fractional", "value": 0.2, "meaning": "fifth part", "gender": "all"},
            "cha·π≠·π≠habhƒÅga": {"type": "fractional", "value": 0.17, "meaning": "sixth part", "gender": "all"},
            "sattamabhƒÅga": {"type": "fractional", "value": 0.14, "meaning": "seventh part", "gender": "all"},
            "a·π≠·π≠hamabhƒÅga": {"type": "fractional", "value": 0.125, "meaning": "eighth part", "gender": "all"},
            "navamabhƒÅga": {"type": "fractional", "value": 0.11, "meaning": "ninth part", "gender": "all"},
            "dasamabhƒÅga": {"type": "fractional", "value": 0.1, "meaning": "tenth part", "gender": "all"},
            "vƒ´satimabhƒÅga": {"type": "fractional", "value": 0.05, "meaning": "twentieth part", "gender": "all"},
            "satamabhƒÅga": {"type": "fractional", "value": 0.01, "meaning": "hundredth part", "gender": "all"},
            
            # Temporal numbers
            "saki·πÉ": {"type": "temporal", "value": 1, "meaning": "once", "gender": "all"},
            "duvi·πÉ": {"type": "temporal", "value": 2, "meaning": "twice", "gender": "all"},
            "ti·πÉ": {"type": "temporal", "value": 3, "meaning": "thrice", "gender": "all"},
            "catu·πÉ": {"type": "temporal", "value": 4, "meaning": "four times", "gender": "all"},
            "pa√±cakkhatta·πÉ": {"type": "temporal", "value": 5, "meaning": "five times", "gender": "all"},
            "chakkhatta·πÉ": {"type": "temporal", "value": 6, "meaning": "six times", "gender": "all"},
            "sattakkhatta·πÉ": {"type": "temporal", "value": 7, "meaning": "seven times", "gender": "all"},
            "a·π≠·π≠hakkhatta·πÉ": {"type": "temporal", "value": 8, "meaning": "eight times", "gender": "all"},
            "navakkhatta·πÉ": {"type": "temporal", "value": 9, "meaning": "nine times", "gender": "all"},
            "dasakkhatta·πÉ": {"type": "temporal", "value": 10, "meaning": "ten times", "gender": "all"},
            "satakkhatta·πÉ": {"type": "temporal", "value": 100, "meaning": "hundred times", "gender": "all"},
            "sahassakkhatta·πÉ": {"type": "temporal", "value": 1000, "meaning": "thousand times", "gender": "all"},
            "ko·π≠isatasakkhatta·πÉ": {"type": "temporal", "value": 1000000000, "meaning": "billion times", "gender": "all"},
            "asa·πÖkhyeyyakkhatta·πÉ": {"type": "temporal", "value": "‚àû", "meaning": "incalculable times", "gender": "all"},
            
            # Measurement numbers
            "a·πÖgula": {"type": "measurement", "value": "finger", "meaning": "finger-width", "gender": "all"},
            "vitthƒÅra": {"type": "measurement", "value": "span", "meaning": "span", "gender": "all"},
            "hattha": {"type": "measurement", "value": "cubit", "meaning": "cubit", "gender": "all"},
            "kamma": {"type": "measurement", "value": "step", "meaning": "pace", "gender": "all"},
            "usabha": {"type": "measurement", "value": "fathom", "meaning": "fathom", "gender": "all"},
            "dhanu": {"type": "measurement", "value": "bow", "meaning": "bow-length", "gender": "all"},
            "nƒÅ·∏∑ƒ´": {"type": "measurement", "value": "measure", "meaning": "measure", "gender": "all"},
            "ƒÅ·∏∑haka": {"type": "measurement", "value": "bushel", "meaning": "bushel", "gender": "all"},
            "do·πáa": {"type": "measurement", "value": "measure", "meaning": "measure", "gender": "all"},
            "khƒÅri": {"type": "measurement", "value": "cartload", "meaning": "cartload", "gender": "all"},
            "vƒÅha": {"type": "measurement", "value": "cartload", "meaning": "cartload", "gender": "all"},
        }
    
    def _initialize_extended_onomatopoeia(self) -> Dict[str, str]:
        """Extended onomatopoeia and sound symbolism"""
        return {
            # Sound of bells and music
            "ki·πÖki·πái": "tinkling of small bells",
            "jha√±jha√±": "clanging of large bells",
            "·π≠ha√±·π≠ha·πá": "beating of drums",
            "di·πÖdi·πÖ": "ringing sound",
            "si·πÖsi·πÖ": "whistling sound",
            "ninnana·πÉ": "humming sound",
            "sarasara": "rustling, soft sound",
            "sirisiri": "sizzling sound",
            
            # Animal sounds
            "ambƒÅ": "bleating of goats",
            "bha·πÉbha·πÉ": "lowing of cattle",
            "hi·πÖhi·πÖ": "neighing of horses",
            "kikira": "crowing of cocks",
            "kukk≈´": "cooing of doves",
            "kƒÅkakƒÅ": "cawing of crows",
            "sikhƒ´": "crying of peacocks",
            "bhambhara": "buzzing of bees",
            "jhi·πÖjhi·πÖ": "chirping of insects",
            "si·πÉsimƒÅya": "roaring of lions",
            
            # Natural sounds
            "ga·∏çaga·∏ça": "rumbling of thunder",
            "garugaru": "thundering sound",
            "jalajala": "splashing of water",
            "calacala": "flowing of water",
            "sƒÅsƒÅ": "whistling of wind",
            "sussu": "hissing sound",
            "phussa": "whispering sound",
            "matmatƒÅya": "crackling of fire",
            "cicci·π≠a": "crackling sound",
            "dhamdhamƒÅya": "throbbing sound",
            
            # Human sounds
            "kila": "shouting",
            "kilakila": "laughing heartily",
            "rudrudrƒÅya": "weeping",
            "rodarodƒÅ": "crying",
            "assa": "sighing",
            "hƒÅhƒÅ": "laughing",
            "huhu·πÖkƒÅra": "grunting",
            "khipakkhipa": "chattering",
            "bhabbhabba": "babbling",
            "phussa": "whispering",
            
            # Movement sounds
            "khalakhala": "clattering",
            "·π≠ha·π≠ha·π≠ha": "pattering",
            "dhapphadhappa": "flapping",
            "papphalaphala": "flopping",
            "cu·πÖcu·πÖ": "jingling",
            "phutphut": "puffing",
            "dhutadhuta": "shaking",
            "pallallapa": "trembling",
            
            # Breaking and impact sounds
            "bha√±jabha√±ja": "breaking",
            "kha·πá·∏çakha·πá·∏ça": "shattering",
            "phalaphalƒÅ": "splitting",
            "·π≠happha·π≠happa": "slapping",
            "dhapphadhappa": "beating",
            "phussaphassa": "touching lightly",
            "gha·π≠·π≠agha·π≠·π≠a": "rubbing",
            "khajjakhajja": "gnawing",
            
            # Liquid sounds
            "bubbu·∏∑a": "bubbling",
            "udakulƒ´": "gurgling",
            "plƒÅplƒÅ": "splashing lightly",
            "dhƒÅrƒÅdhƒÅrƒÅ": "streaming",
            "picchilapicchila": "dripping",
            "tapphatappa": "dripping quickly",
            "visavisƒÅ": "oozing",
            "sandasanda": "flowing",
            
            # Mental states (sound symbolism)
            "tu·πÖhƒ´": "silent, speechless",
            "nissadda": "soundless",
            "nibbija·πÖkƒÅra": "without murmur",
            "appasadda": "with little sound",
            "uccƒÅsadda": "loud, noisy",
            "mahƒÅsadda": "very loud",
            "vitthƒÅrasadda": "extended sound",
            "vikatthanƒÅ": "boasting",
            
            # Ritual sounds
            "svƒÅhƒÅ": "ritual exclamation",
            "sƒÅdhu": "expression of approval",
            "aho": "expression of wonder",
            "handa": "come on!",
            "kha·πá·∏ça": "breaking sound in ritual",
            "ma·πÖgala": "auspicious sound",
            "jayƒÅ": "victory cry",
            "jƒ´va": "long live!",
            
            # Emotional expressions
            "ucchaleti": "jumps with joy",
            "kampeti": "trembles",
            "vedhati": "thrills",
            "pulakita": "thrilled (hair standing)",
            "lomahattho": "hair-raising",
            "sƒÅrambha": "enthusiastic sound",
            "utsƒÅha": "energetic expression",
            "vismaya": "wondering sound",
            
            # Temporal sound patterns
            "·π≠hapetvƒÅ": "placed sound",
            "ugghƒÅ·π≠ana": "opening sound",
            "pihana": "closing sound",
            "vivara·πáa": "uncovering sound",
            "chƒÅdana": "covering sound",
            "sampadƒÅna": "completion sound",
            "ƒÅrabbhana": "beginning sound",
            "ni·π≠·π≠hƒÅpana": "finishing sound",
        }
    
    def _initialize_synonyms_antonyms(self) -> Dict[str, Dict[str, List[str]]]:
        """Comprehensive synonyms and antonyms"""
        return {
            "synonyms": {
                "buddha": ["tathƒÅgata", "sugata", "bhagavƒÅ", "sammƒÅsambuddha", "jina", "dasabala"],
                "dhamma": ["desanƒÅ", "sƒÅsana", "vacana", "ovƒÅda", "anusƒÅsanƒ´", "naya"],
                "sa·πÖgha": ["ga·πáa", "p≈´ga", "nikƒÅya", "parisa", "sam≈´ha", "ma·πá·∏çala"],
                "nibbƒÅna": ["amata", "moksa", "vimutti", "viveka", "santa", "siva"],
                "dukkha": ["domanassa", "dukkhitƒÅ", "ƒÅbƒÅdha", "vighƒÅta", "upaddava", "vipatti"],
                "sukha": ["somanassa", "rati", "mudƒÅ", "pƒÅmojja", "tu·π≠·π≠hi", "santu·π≠·π≠hi"],
                "citta": ["mano", "hadaya", "ura", "ceto", "manas", "vi√±√±ƒÅ·πáa"],
                "pa√±√±ƒÅ": ["√±ƒÅ·πáa", "vijjƒÅ", "praj√±ƒÅ", "buddhi", "medhƒÅ", "pƒÅ·π≠ava"],
                "mettƒÅ": ["mudƒÅ", "sneha", "pemƒÅ", "dayƒÅ", "karu·πáƒÅ", "anukampƒÅ"],
                "sƒ´la": ["ƒÅcƒÅra", "cara·πáa", "caritta", "vrata", "niyama", "sa·πÉvara"],
                "samƒÅdhi": ["samatha", "jhƒÅna", "ekaggatƒÅ", "cittassa-ekaggitƒÅ", "yoga", "upasama"],
                "magga": "patha", "pa·π≠ipadƒÅ", "naya", "gati", "a√±jasa", "ujuka"],
                "phala": ["vipƒÅka", "attha", "ƒÅnisa·πÉsa", "paccupa·π≠·π≠hƒÅna", "lƒÅbha", "sampatti"],
                "kamma": ["kiriyƒÅ", "kara·πáa", "ce·π≠·π≠ƒÅ", "payoga", "vƒÅyƒÅma", "ussƒÅha"],
            },
            "antonyms": {
                "sukha": ["dukkha", "domanassa", "dukkhitƒÅ", "ƒÅbƒÅdha", "vighƒÅta"],
                "kusala": ["akusala", "pƒÅpa", "kamma", "duccarita", "aparƒÅddha"],
                "√±ƒÅ·πáa": ["avijjƒÅ", "a√±√±ƒÅ·πáa", "moha", "samm≈´·∏∑ha", "andha"],
                "sƒ´la": ["dussƒ´la", "duccarita", "micchƒÅcƒÅra", "aparƒÅddha", "ƒÅpatti"],
                "santo": ["asanto", "calita", "uddha", "vikkhitta", "vighƒÅta"],
                "kusalƒÅ": ["akusalƒÅ", "a·π≠hƒ´", "nipu·πáƒÅ", "pa·πá·∏çitƒÅ", "medhƒÅvƒ´"],
                "dƒÅna": ["macchariya", "kadariya", "thƒ´na", "kasƒÅva", "matsarya"],
                "mettƒÅ": ["dosa", "vera", "byƒÅpƒÅda", "pa·π≠igha", "kodha"],
                "sammƒÅ": ["micchƒÅ", "viparƒ´ta", "vipallƒÅsa", "vipanna", "parƒÅmuttha"],
                "ƒÅraddha": ["kusƒ´ta", "alasa", "anussuka", "anu·π≠·π≠hita", "pamatta"],
                "sata": ["pamatta", "mu·π≠·π≠hasati", "asampajƒÅna", "amanasikƒÅra", "pamƒÅda"],
                "ekagga": ["vikkhitta", "v≈´pasanta", "luddha", "parƒÅmuttha", "visa·πÉyutta"],
            }
        }
    
    def _initialize_etymology_database(self) -> Dict[str, Dict[str, str]]:
        """Etymology and word formation information"""
        return {
            "buddha": {
                "root": "‚àöbudh",
                "meaning": "wake up, understand",
                "formation": "past_participle",
                "cognates": ["Sanskrit: buddha", "Hindi: buddh"],
                "development": "Vedic ‚àöbudh > Pali buddha"
            },
            "dhamma": {
                "root": "‚àödhar",
                "meaning": "hold, bear, support",
                "formation": "action_noun",
                "cognates": ["Sanskrit: dharma", "Hindi: dharm"],
                "development": "Vedic dharma > Pali dhamma"
            },
            "sa·πÖgha": {
                "root": "‚àösa·πÉ-gam",
                "meaning": "come together",
                "formation": "collective_noun",
                "cognates": ["Sanskrit: sa·πÖgha", "Hindi: sangh"],
                "development": "Vedic sa·πÖgha > Pali sa·πÖgha"
            },
            "nibbƒÅna": {
                "root": "‚àönir-vƒÅ",
                "meaning": "blow out, extinguish",
                "formation": "past_participle",
                "cognates": ["Sanskrit: nirvƒÅ·πáa", "Hindi: nirvan"],
                "development": "Vedic nirvƒÅ·πáa > Pali nibbƒÅna"
            },
            "kamma": {
                "root": "‚àökar",
                "meaning": "do, make",
                "formation": "action_noun",
                "cognates": ["Sanskrit: karma", "Hindi: karm"],
                "development": "Vedic karma > Pali kamma"
            },
        }
    
    def _initialize_usage_examples(self) -> Dict[str, List[str]]:
        """Usage examples from canonical texts"""
        return {
            "buddha": [
                "Buddho bhagavƒÅ araha·πÉ sammƒÅsambuddho",
                "Namo tassa bhagavato arahato sammƒÅsambuddhassa",
                "Buddha·πÉ sara·πáa·πÉ gacchƒÅmi"
            ],
            "dhamma": [
                "SvƒÅkkhƒÅto bhagavatƒÅ dhammo",
                "Dhamma·πÉ sara·πáa·πÉ gacchƒÅmi",
                "Dhammacakkappavattana"
            ],
            "sa·πÖgha": [
                "Supa·π≠ipanno bhagavato sƒÅvakasa·πÖgho",
                "Sa·πÖgha·πÉ sara·πáa·πÉ gacchƒÅmi",
                "Sa·πÖghe buddhaputtesu"
            ],
        }
    
    def _initialize_metrical_variants(self) -> Dict[str, List[str]]:
        """Alternative forms for metrical purposes"""
        return {
            "nibbƒÅna": ["nibbƒÅ·πáa", "nibbƒÅ·πáa·πÉ", "nibbuti"],
            "buddha": ["buddho", "buddhassa", "budhassa"],
            "dhamma": ["dhammo", "dhammassa", "dhƒÅma"],
            "pa√±√±ƒÅ": ["pa√±√±a·πÉ", "pa√±√±ƒÅya", "pa√±√±o"],
            "citta": ["citta·πÉ", "ceto", "ceta·πÉ"],
            "r≈´pa": ["r≈´pa·πÉ", "r≈´vo", "r≈´vassa"],
        }
    
    def _initialize_register_variations(self) -> Dict[str, Dict[str, str]]:
        """Register variations (formal/informal/poetic/etc.)"""
        return {
            "formal": {
                "buddha": "bhagavƒÅ sammƒÅsambuddho",
                "monk": "mahƒÅthera bhaddanta",
                "eat": "bhu√±jati ƒÅhƒÅra·πÉ",
                "go": "gacchati yena",
                "speak": "bhƒÅsati vacana·πÉ"
            },
            "informal": {
                "buddha": "buddha",
                "monk": "bhikkhu",
                "eat": "khƒÅdati",
                "go": "gacchati",
                "speak": "vadati"
            },
            "poetic": {
                "buddha": "jina dasabala",
                "monk": "bhikkhusa·πÖgha",
                "eat": "bhu√±janta ƒÅhƒÅra",
                "go": "yƒÅyanta magga",
                "speak": "bhƒÅsamƒÅna dhamma"
            },
            "archaic": {
                "buddha": "tathƒÅgata sugata",
                "monk": "sama·πáa brƒÅhma·πáa",
                "eat": "bhu√±jamƒÅna",
                "go": "gacchamƒÅna",
                "speak": "vadamƒÅna"
            }
        }
    
    def _initialize_historical_layers(self) -> Dict[str, Dict[str, str]]:
        """Historical development layers"""
        return {
            "early_pali": {
                "buddha": "buddha",
                "dhamma": "dhamma", 
                "meditation": "jhƒÅna",
                "wisdom": "pa√±√±ƒÅ"
            },
            "middle_pali": {
                "buddha": "bhagavƒÅ",
                "dhamma": "sƒÅsana",
                "meditation": "samƒÅdhi",
                "wisdom": "√±ƒÅ·πáa"
            },
            "late_pali": {
                "buddha": "sammƒÅsambuddha",
                "dhamma": "buddhavacana",
                "meditation": "bhƒÅvanƒÅ",
                "wisdom": "vijjƒÅ"
            }
        }
    
    def _initialize_semantic_networks(self) -> Dict[str, Dict[str, List[str]]]:
        """Semantic relationship networks"""
        return {
            "enlightenment": {
                "core": ["buddha", "bodhi", "nibbƒÅna", "vimutti"],
                "path": ["magga", "pa·π≠ipadƒÅ", "sƒ´la", "samƒÅdhi", "pa√±√±ƒÅ"],
                "obstacles": ["kilesa", "ƒÅsava", "sa·πÉyojana", "nƒ´vara·πáa"],
                "qualities": ["karu·πáƒÅ", "mettƒÅ", "muditƒÅ", "upekkhƒÅ"]
            },
            "meditation": {
                "practices": ["satipa·π≠·π≠hƒÅna", "ƒÅnƒÅpƒÅnasati", "jhƒÅna", "vipassanƒÅ"],
                "states": ["samƒÅdhi", "ekaggatƒÅ", "passaddhi", "sukha"],
                "objects": ["kasi·πáa", "ƒÅnƒÅpƒÅna", "kƒÅyagatƒÅsati", "mettƒÅ"],
                "stages": ["vitakka", "vicƒÅra", "pƒ´ti", "sukha", "ekaggatƒÅ"]
            }
        }
    
    def _initialize_canonical_citations(self) -> Dict[str, List[str]]:
        """Canonical text citations for words"""
        return {
            "buddha": ["DN 14", "MN 26", "SN 56.11", "Dhp 183-185"],
            "dhamma": ["DN 16", "MN 141", "SN 22.85", "Dhp 1-2"],
            "sa·πÖgha": ["DN 16", "MN 118", "AN 4.4", "Dhp 194-196"],
            "nibbƒÅna": ["SN 43.1-44", "Ud 8.1-4", "It 37-43"],
            "satipa·π≠·π≠hƒÅna": ["DN 22", "MN 10", "SN 47.1-104"],
        }

# ============ ULTIMATE COMPOUND SEMANTIC COMPOSITOR ============

class UltimateCompoundSemanticCompositor(CompoundSemanticCompositor):
    """Ultimate compound generator with unlimited capacity"""
    
    def __init__(self, kb):
        super().__init__(kb)
        
        # Enhanced patterns for massive generation
        self.massive_generation_patterns = self._initialize_massive_patterns()
        self.systematic_combinations = self._initialize_systematic_combinations()
        
    def _initialize_massive_patterns(self):
        """Patterns for massive systematic generation"""
        return {
            "religious_systematic": {
                "buddha_compounds": ["buddha+X", "X+buddha", "buddha+X+Y"],
                "dhamma_compounds": ["dhamma+X", "X+dhamma", "dhamma+X+Y"],
                "sa·πÖgha_compounds": ["sa·πÖgha+X", "X+sa·πÖgha", "sa·πÖgha+X+Y"],
                "tiratana_compounds": ["buddha+dhamma+X", "dhamma+sa·πÖgha+X", "buddha+sa·πÖgha+X"]
            },
            "philosophical_systematic": {
                "truth_compounds": ["sacca+X", "X+sacca", "ariya+sacca+X"],
                "path_compounds": ["magga+X", "X+magga", "a·π≠·π≠ha·πÖgika+magga+X"],
                "liberation_compounds": ["vimutti+X", "X+vimutti", "cetaso+vimutti+X"],
                "wisdom_compounds": ["pa√±√±ƒÅ+X", "X+pa√±√±ƒÅ", "sammƒÅ+pa√±√±ƒÅ+X"]
            },
            "meditation_systematic": {
                "jhana_compounds": ["jhƒÅna+X", "X+jhƒÅna", "pa·π≠hama+jhƒÅna+X"],
                "samadhi_compounds": ["samƒÅdhi+X", "X+samƒÅdhi", "samma+samƒÅdhi+X"],
                "sati_compounds": ["sati+X", "X+sati", "samma+sati+X"],
                "bhavana_compounds": ["bhƒÅvanƒÅ+X", "X+bhƒÅvanƒÅ", "citta+bhƒÅvanƒÅ+X"]
            }
        }
    
    def _initialize_systematic_combinations(self):
        """All possible systematic combinations"""
        return {
            "adjective_noun": "all_adjectives √ó all_nouns",
            "noun_noun": "all_nouns √ó all_nouns",
            "number_noun": "all_numbers √ó all_countable_nouns",
            "prefix_word": "all_prefixes √ó all_suitable_words",
            "quality_entity": "all_qualities √ó all_entities",
            "action_object": "all_actions √ó all_objects",
            "temporal_noun": "all_temporal √ó all_nouns",
            "spatial_noun": "all_spatial √ó all_nouns"
        }
    
    def generate_unlimited_compounds(self, semantic_fields, max_total=100000):
        """Generate unlimited compounds systematically"""
        compounds = {}
        
        print("   üìù Phase 1: Basic systematic combinations...")
        basic_compounds = self._generate_all_basic_combinations(semantic_fields, max_total // 4)
        compounds.update(basic_compounds)
        
        print("   üìù Phase 2: Religious/philosophical compounds...")
        religious_compounds = self._generate_religious_philosophical_compounds(semantic_fields, max_total // 4)
        compounds.update(religious_compounds)
        
        print("   üìù Phase 3: Technical/specialized compounds...")
        technical_compounds = self._generate_technical_specialized_compounds(semantic_fields, max_total // 4)
        compounds.update(technical_compounds)
        
        print("   üìù Phase 4: Multi-level recursive compounds...")
        recursive_compounds = self._generate_multi_level_recursive_compounds(compounds, max_total // 4)
        compounds.update(recursive_compounds)
        
        return compounds
    
    def _generate_all_basic_combinations(self, semantic_fields, max_count):
        """Generate ALL basic two-word combinations"""
        compounds = {}
        count = 0
        
        # Get all words by category
        all_words = []
        for field, words in semantic_fields.items():
            all_words.extend(words)
        
        # Remove duplicates
        all_words = list(set(all_words))
        
        # Generate all meaningful combinations
        for i, word1 in enumerate(all_words):
            if count >= max_count:
                break
                
            for j, word2 in enumerate(all_words):
                if i == j or count >= max_count:
                    continue
                
                # Check if combination is meaningful
                if self._is_meaningful_combination(word1, word2):
                    # Apply sandhi
                    compound = self._apply_compound_sandhi([word1, word2])
                    
                    if (compound not in compounds and 
                        compound not in self.generated_compounds):
                        
                        # Determine compound type
                        compound_type = self._determine_compound_type(word1, word2)
                        
                        # Generate meaning
                        meaning = self.compose_meaning([word1, word2], compound_type)
                        
                        compounds[compound] = {
                            "components": [word1, word2],
                            "type": compound_type,
                            "meaning": meaning,
                            "frequency": self._calculate_combination_frequency(word1, word2)
                        }
                        
                        self.generated_compounds.add(compound)
                        count += 1
        
        return compounds
    
    def _generate_religious_philosophical_compounds(self, semantic_fields, max_count):
        """Generate all religious and philosophical compounds"""
        compounds = {}
        count = 0
        
        # Core religious terms
        religious_cores = ["buddha", "dhamma", "sa·πÖgha", "nibbƒÅna", "kamma", "sƒ´la", "samƒÅdhi", "pa√±√±ƒÅ"]
        philosophical_cores = ["sacca", "magga", "phala", "vimutti", "bodhi", "√±ƒÅ·πáa", "karu·πáƒÅ", "mettƒÅ"]
        
        # All other suitable words
        all_others = []
        for field, words in semantic_fields.items():
            if field not in ["particles", "prefixes"]:
                all_others.extend(words)
        
        all_others = list(set(all_others))
        
        # Generate religious compounds
        for core in religious_cores + philosophical_cores:
            if count >= max_count:
                break
                
            for other in all_others:
                if count >= max_count:
                    break
                
                # Try both orders
                for word1, word2 in [(core, other), (other, core)]:
                    if word1 == word2:
                        continue
                    
                    compound = self._apply_compound_sandhi([word1, word2])
                    
                    if (compound not in compounds and 
                        compound not in self.generated_compounds):
                        
                        compound_type = self._determine_religious_compound_type(word1, word2, core)
                        meaning = self._compose_religious_meaning([word1, word2], compound_type, core)
                        
                        compounds[compound] = {
                            "components": [word1, word2],
                            "type": f"religious_{compound_type}",
                            "meaning": meaning,
                            "religious_core": core,
                            "frequency": 3.5
                        }
                        
                        self.generated_compounds.add(compound)
                        count += 1
        
        return compounds
    
    def _generate_technical_specialized_compounds(self, semantic_fields, max_count):
        """Generate technical and specialized compounds"""
        compounds = {}
        count = 0
        
        # Technical vocabulary
        technical_vocab = []
        if hasattr(self.kb, 'comprehensive_technical_vocabulary'):
            for field, terms in self.kb.comprehensive_technical_vocabulary.items():
                technical_vocab.extend(terms)
        
        # Generate technical compounds
        for i, term1 in enumerate(technical_vocab):
            if count >= max_count:
                break
                
            for j, term2 in enumerate(technical_vocab):
                if i == j or count >= max_count:
                    continue
                
                compound = self._apply_compound_sandhi([term1, term2])
                
                if (compound not in compounds and 
                    compound not in self.generated_compounds):
                    
                    meaning = f"technical compound of {term1} and {term2}"
                    
                    compounds[compound] = {
                        "components": [term1, term2],
                        "type": "technical_compound",
                        "meaning": meaning,
                        "frequency": 2.5
                    }
                    
                    self.generated_compounds.add(compound)
                    count += 1
        
        return compounds
    
    def _generate_multi_level_recursive_compounds(self, existing_compounds, max_count):
        """Generate 3, 4, and 5 word compounds"""
        compounds = {}
        count = 0
        
        # Select base compounds for recursion
        suitable_bases = [
            (comp, info) for comp, info in existing_compounds.items()
            if len(info["components"]) == 2
        ]
        
        # Additional elements for extension
        extensions = ["√±ƒÅ·πáa", "dassana", "vimutti", "magga", "phala", "sampatti", 
                     "pa·π≠ilƒÅbha", "adhigama", "pa·π≠iveda", "sacchikiriyƒÅ"]
        
        # Generate 3-word compounds
        for base_compound, base_info in suitable_bases[:1000]:  # Limit base compounds
            if count >= max_count:
                break
                
            for ext in extensions:
                if count >= max_count:
                    break
                
                # Create 3-word compound
                components = base_info["components"] + [ext]
                compound = self._apply_compound_sandhi(components)
                
                if (compound not in compounds and 
                    compound not in self.generated_compounds):
                    
                    base_meaning = base_info["meaning"]
                    ext_meaning = self._get_word_meaning(ext)
                    full_meaning = f"{ext_meaning} of {base_meaning}"
                    
                    compounds[compound] = {
                        "components": components,
                        "type": "three_word_compound",
                        "meaning": full_meaning,
                        "base_compound": base_compound,
                        "depth": 3,
                        "frequency": 2.0
                    }
                    
                    self.generated_compounds.add(compound)
                    count += 1
        
        # Generate 4-word compounds from 3-word compounds
        three_word_compounds = [
            (comp, info) for comp, info in compounds.items()
            if info.get("depth") == 3
        ]
        
        for base_compound, base_info in three_word_compounds[:500]:
            if count >= max_count:
                break
            
            for ext in extensions[:3]:  # Limit extensions for 4-word
                if count >= max_count:
                    break
                
                components = base_info["components"] + [ext]
                compound = self._apply_compound_sandhi(components)
                
                if (compound not in compounds and 
                    compound not in self.generated_compounds):
                    
                    base_meaning = base_info["meaning"]
                    ext_meaning = self._get_word_meaning(ext)
                    full_meaning = f"{ext_meaning} involving {base_meaning}"
                    
                    compounds[compound] = {
                        "components": components,
                        "type": "four_word_compound",
                        "meaning": full_meaning,
                        "base_compound": base_compound,
                        "depth": 4,
                        "frequency": 1.8
                    }
                    
                    self.generated_compounds.add(compound)
                    count += 1
        
        return compounds
    
    def _is_meaningful_combination(self, word1, word2):
        """Check if two words can form a meaningful compound"""
        # Get semantic fields for both words
        fields1 = self._get_semantic_fields(word1)
        fields2 = self._get_semantic_fields(word2)
        
        # Avoid meaningless combinations
        meaningless_combinations = [
            (["particles"], ["particles"]),
            (["prefixes"], ["prefixes"]),
            (["numbers"], ["numbers"]),
        ]
        
        for combo in meaningless_combinations:
            if (any(f in combo[0] for f in fields1) and 
                any(f in combo[1] for f in fields2)):
                return False
        
        # Encourage meaningful combinations
        meaningful_combinations = [
            (["qualities"], ["beings"]),
            (["action"], ["objects"]),
            (["temporal"], ["events"]),
            (["spatial"], ["entities"]),
            (["mind"], ["qualities"]),
            (["enlightenment"], ["path"]),
            (["ethics"], ["practice"]),
        ]
        
        for combo in meaningful_combinations:
            if (any(f in combo[0] for f in fields1) and 
                any(f in combo[1] for f in fields2)):
                return True
        
        # Default: allow if not explicitly meaningless
        return True
    
    def _determine_compound_type(self, word1, word2):
        """Determine compound type based on semantic analysis"""
        fields1 = self._get_semantic_fields(word1)
        fields2 = self._get_semantic_fields(word2)
        
        # Tatpuru·π£a patterns
        if any(f in ["beings", "society"] for f in fields1):
            return "tatpurusa"
        
        # KarmadhƒÅraya patterns
        if any(f in ["qualities", "colors"] for f in fields1):
            return "karmadharaya"
        
        # Bahuvrƒ´hi patterns
        if any(f in ["body", "faculties"] for f in fields2):
            return "bahuvrihi"
        
        # Dvandva patterns
        if fields1 == fields2:
            return "dvandva"
        
        # Default
        return "tatpurusa"
    
    def _determine_religious_compound_type(self, word1, word2, core):
        """Determine type for religious compounds"""
        if core == word1:
            return "core_modifier"  # buddha+X
        elif core == word2:
            return "modifier_core"  # X+buddha
        else:
            return "religious_tatpurusa"
    
    def _compose_religious_meaning(self, components, compound_type, core):
        """Compose meaning for religious compounds"""
        meanings = [self._get_word_meaning(comp) for comp in components]
        
        if compound_type == "core_modifier":
            return f"{meanings[0]}'s {meanings[1]}"
        elif compound_type == "modifier_core":
            return f"{meanings[1]} of {meanings[0]}"
        else:
            return f"{meanings[1]} related to {meanings[0]}"
    
    def _calculate_combination_frequency(self, word1, word2):
        """Calculate frequency for word combinations"""
        # Get base frequencies
        freq1 = self._get_word_frequency(word1)
        freq2 = self._get_word_frequency(word2)
        
        # Calculate combined frequency
        combined = (freq1 + freq2) / 2
        
        # Apply combination penalty
        return combined * 0.8
    
    def _get_word_frequency(self, word):
        """Get frequency for a word"""
        if word in self.kb.base_meanings:
            return self.kb.base_meanings[word].get("frequency", 3.0)
        elif hasattr(self.kb, 'comprehensive_indeclinables') and word in self.kb.comprehensive_indeclinables:
            return self.kb.comprehensive_indeclinables[word].get("frequency", 3.0)
        else:
            return 3.0

# ============ ULTIMATE MONUMENTAL PALI DICTIONARY GENERATOR ============

class UltimateMonumentalPaliDictionaryGenerator(MonumentalPaliDictionaryGenerator):
    """The ultimate, complete, and definitive implementation"""
    
    def __init__(self, kaggle_mode=False):
        print("üî¨ Initializing ULTIMATE Monumental Pali Dictionary Generator...")
        
        # Detect environment
        self.kaggle_mode = kaggle_mode or os.path.exists('/kaggle/input')
        
        # Initialize ULTIMATE knowledge base
        self.kb = UltimateExhaustivePaliSemanticKnowledgeBase(self.kaggle_mode)
        
        # Initialize ULTIMATE generators
        print("üîß Initializing Ultimate Generators...")
        self.compound_compositor = UltimateCompoundSemanticCompositor(self.kb)
        self.morphological_generator = MorphologicalSemanticGenerator(self.kb)
        self.derivational_generator = DerivationalSemanticGenerator(self.kb)
        self.validator = SemanticValidator()
        
        # Dictionary storage
        self.generated_dict = {}
        self.generation_stats = defaultdict(int)
        self.quality_stats = defaultdict(int)
        
        # NO LIMITS - Ultimate generation
        self.limits = {
            "morphological_forms_per_word": 1000,    # All possible forms
            "verbal_forms_per_root": 1000,           # All tenses/persons/numbers
            "compounds_per_type": 50000,             # Massive compound generation
            "derivatives_per_pattern": 10000,        # All derivatives
            "sandhi_variants_per_word": 100,         # Comprehensive sandhi
            "max_recursive_depth": 5,                # Deep recursion
            "max_total_target": 1000000              # 1 million entries target
        }
        
        # Load existing dictionary
        self.existing_dict_path = "pali_dictionary.json"
        self.existing_words = set()
        self._load_existing_dictionary()
    
    def generate_ultimate_dictionary(self):
        """Generate the ultimate complete dictionary"""
        print("\nüöÄ GENERATING ULTIMATE MONUMENTAL PALI DICTIONARY")
        print("=" * 80)
        print("Target: 1,000,000+ entries with perfect quality")
        
        start_time = datetime.now()
        
        # Phase 1: Generate ALL base entries with all variants
        print("\nüìç Phase 1: Ultimate Base Entries")
        self._generate_ultimate_base_entries()
        
        # Phase 2: Generate ALL morphological forms (no limits)
        print("\nüìç Phase 2: Complete Morphological Universe")
        self._generate_complete_morphological_universe()
        
        # Phase 3: Generate ALL prefixed forms
        print("\nüìç Phase 3: Complete Prefixed Form Universe")
        self._generate_complete_prefixed_universe()
        
        # Phase 4: Generate ALL compounds with unlimited recursion
        print("\nüìç Phase 4: Unlimited Compound Generation")
        self._generate_unlimited_compounds()
        
        # Phase 5: Generate ALL derivatives and secondary derivatives
        print("\nüìç Phase 5: Complete Derivational Universe")
        self._generate_complete_derivational_universe()
        
        # Phase 6: Generate ALL technical vocabulary
        print("\nüìç Phase 6: Complete Technical Vocabulary")
        self._generate_complete_technical_vocabulary()
        
        # Phase 7: Generate ALL phrasal expressions
        print("\nüìç Phase 7: Complete Phrasal Universe")
        self._generate_complete_phrasal_universe()
        
        # Phase 8: Generate ALL numerical expressions
        print("\nüìç Phase 8: Complete Numerical Universe")
        self._generate_complete_numerical_universe()
        
        # Phase 9: Generate ALL sandhi variants
        print("\nüìç Phase 9: Complete Sandhi Universe")
        self._generate_complete_sandhi_universe()
        
        # Phase 10: Generate proper name declensions
        print("\nüìç Phase 10: Complete Proper Name Universe")
        self._generate_complete_proper_name_universe()
        
        # Phase 11: Ultimate validation and enhancement
        print("\nüìç Phase 11: Ultimate Validation and Enhancement")
        self._ultimate_validation_and_enhancement()
        
        # Calculate generation time
        end_time = datetime.now()
        generation_time = (end_time - start_time).total_seconds()
        
        # Final statistics
        print(f"\nüìä ULTIMATE GENERATION COMPLETE!")
        print(f"   Total entries: {len(self.generated_dict):,}")
        print(f"   Generation time: {generation_time:.2f} seconds")
        print(f"   Entries per second: {len(self.generated_dict)/generation_time:.0f}")
        
        # Quality analysis
        quality_percentage = (self.quality_stats.get("excellent", 0) + 
                            self.quality_stats.get("good", 0)) / len(self.generated_dict) * 100
        print(f"   Quality (good+excellent): {quality_percentage:.1f}%")
        
        print(f"\n   Ultimate breakdown by category:")
        for category, count in sorted(self.generation_stats.items()):
            if category not in ["invalid_removed", "meanings_enhanced", "average_quality"]:
                print(f"   - {category}: {count:,}")
        
        return self.generated_dict
    
    def _generate_ultimate_base_entries(self):
        """Generate all possible base entries"""
        count = 0
        
        # Process ALL base words
        for word, info in self.kb.base_meanings.items():
            if word not in self.existing_words:
                # Create comprehensive entry
                entry = self._create_comprehensive_base_entry(word, info)
                self.generated_dict[word] = entry
                count += 1
                
                # Generate ALL contextual variants
                if hasattr(self.kb, 'contextual_meanings') and word in self.kb.contextual_meanings:
                    context_count = self._generate_all_contextual_variants(word, self.kb.contextual_meanings[word])
                    count += context_count
                
                # Generate ALL register variants
                if hasattr(self.kb, 'register_variations'):
                    register_count = self._generate_all_register_variants(word, info)
                    count += register_count
                
                # Generate ALL historical variants
                if hasattr(self.kb, 'historical_layers'):
                    historical_count = self._generate_all_historical_variants(word, info)
                    count += historical_count
        
        # Process ALL indeclinables
        if hasattr(self.kb, 'comprehensive_indeclinables'):
            for word, info in self.kb.comprehensive_indeclinables.items():
                if word not in self.existing_words and word not in self.generated_dict:
                    entry = {
                        "word": word,
                        "meaning": self.validator.enhance_meaning(info["meaning"]),
                        "type": "indeclinable",
                        "subtype": info["type"],
                        "position": info.get("position", "various"),
                        "frequency": info.get("frequency", 3.0),
                        "indeclinable": True
                    }
                    self.generated_dict[word] = entry
                    count += 1
        
        print(f"   ‚úÖ Generated {count} ultimate base entries")
        self.generation_stats["base_words"] = count
    
    def _generate_complete_morphological_universe(self):
        """Generate ALL possible morphological forms"""
        count = 0
        
        # Phase A: ALL nominal forms (no limits)
        print("   üìù Generating ALL nominal forms (unlimited)...")
        count += self._generate_unlimited_nominal_forms()
        
        # Phase B: ALL verbal forms (no limits)
        print("   üìù Generating ALL verbal forms (unlimited)...")
        count += self._generate_unlimited_verbal_forms()
        
        # Phase C: ALL participle forms (complete system)
        print("   üìù Generating complete participle system...")
        count += self._generate_complete_participle_system()
        
        # Phase D: ALL comparison forms
        print("   üìù Generating ALL comparison forms...")
        count += self._generate_all_comparison_forms()
        
        # Phase E: ALL denominative forms
        print("   üìù Generating ALL denominative forms...")
        count += self._generate_all_denominative_forms()
        
        print(f"   ‚úÖ Generated {count} morphological forms total")
        self.generation_stats["morphological_forms"] = count
    
    def _generate_unlimited_nominal_forms(self):
        """Generate ALL nominal forms for ALL words"""
        count = 0
        cases = ["nominative", "accusative", "instrumental", "dative", 
                "ablative", "genitive", "locative", "vocative"]
        numbers = ["singular", "dual", "plural"]
        
        # Process ALL words that can be declined
        declinable_words = []
        
        # Add base words
        for word, info in self.kb.base_meanings.items():
            if info.get("semantic_field") not in ["particles", "prefixes"]:
                declinable_words.append((word, info))
        
        # Add proper names
        if hasattr(self.kb, 'proper_names'):
            for word, info in self.kb.proper_names.items():
                declinable_words.append((word, info))
        
        # Add technical terms
        if hasattr(self.kb, 'comprehensive_technical_vocabulary'):
            for field, terms in self.kb.comprehensive_technical_vocabulary.items():
                for term in terms:
                    if term not in [w[0] for w in declinable_words]:
                        # Create basic info
                        info = {
                            "semantic_field": field,
                            "register": "technical",
                            "gender": "m",  # Default
                            "declension": "a_masculine"  # Default
                        }
                        declinable_words.append((term, info))
        
        # Generate ALL forms for ALL words
        for base, info in declinable_words:
            # Determine possible genders
            genders = self._determine_all_genders(base, info)
            
            for gender in genders:
                for case in cases:
                    for number in numbers:
                        # Skip certain combinations
                        if self._should_skip_form(case, number, info):
                            continue
                        
                        # Generate form
                        form = self._apply_nominal_morphology(base, case, number, gender)
                        
                        if (form and form != base and 
                            form not in self.existing_words and 
                            form not in self.generated_dict and
                            len(form) > 1):
                            
                            # Generate meaning
                            meaning = self.morphological_generator.generate_nominal_meaning(
                                base, case, number, gender
                            )
                            
                            # Validate meaning
                            is_valid, _ = self.validator.validate_meaning(meaning)
                            if is_valid:
                                entry = {
                                    "word": form,
                                    "meaning": self.validator.enhance_meaning(meaning),
                                    "type": "inflected_noun",
                                    "base": base,
                                    "case": case,
                                    "number": number,
                                    "gender": gender,
                                    "semantic_field": info.get("semantic_field", "general"),
                                    "frequency": self._calculate_form_frequency(base, case, number)
                                }
                                
                                # Add additional info
                                if "register" in info:
                                    entry["register"] = info["register"]
                                
                                self.generated_dict[form] = entry
                                count += 1
        
        return count
    
    def _generate_unlimited_verbal_forms(self):
        """Generate ALL verbal forms for ALL roots"""
        count = 0
        persons = ["1st", "2nd", "3rd"]
        numbers = ["singular", "dual", "plural"]
        tenses = ["present", "aorist", "perfect", "future", "imperative", "optative", "conditional"]
        voices = ["active", "middle", "passive", "causative", "desiderative", "intensive", "denominative"]
        
        # Process ALL roots
        for root, info in self.kb.root_meanings.items():
            for voice in voices:
                # Skip impossible combinations
                if not self._is_valid_voice_combination(voice, tenses):
                    continue
                
                for tense in tenses:
                    # Skip invalid combinations
                    if not self._is_valid_tense_voice_combination(tense, voice):
                        continue
                    
                    for person in persons:
                        for number in numbers:
                            # Skip certain combinations
                            if self._should_skip_verbal_form(tense, person, number, voice):
                                continue
                            
                            # Generate form
                            form = self._apply_verbal_morphology(root, person, number, tense, voice)
                            
                            if (form and form not in self.existing_words and 
                                form not in self.generated_dict and
                                len(form) > 2):
                                
                                # Generate meaning
                                meaning = self.morphological_generator.generate_verbal_meaning(
                                    root, person, number, tense, voice
                                )
                                
                                # Validate
                                is_valid, _ = self.validator.validate_meaning(meaning)
                                if is_valid:
                                    entry = {
                                        "word": form,
                                        "meaning": self.validator.enhance_meaning(meaning),
                                        "type": "verb",
                                        "root": root,
                                        "person": person,
                                        "number": number,
                                        "tense": tense,
                                        "voice": voice,
                                        "semantic_field": info.get("semantic_field", "action"),
                                        "frequency": self._calculate_verb_frequency(tense, voice, person, number)
                                    }
                                    
                                    self.generated_dict[form] = entry
                                    count += 1
        
        return count
    
    def _generate_complete_participle_system(self):
        """Generate complete participle system"""
        count = 0
        
        # All participle types
        participle_types = {
            "present_active": {"suffix": "ant", "meaning": "ing", "declinable": True},
            "present_middle": {"suffix": "mƒÅna", "meaning": "ing (reflexive)", "declinable": True},
            "present_passive": {"suffix": "yamƒÅna", "meaning": "being Xed", "declinable": True},
            "past_passive": {"suffix": "ta", "meaning": "ed", "declinable": True},
            "past_active": {"suffix": "tavant", "meaning": "having Xed", "declinable": True},
            "past_middle": {"suffix": "ƒÅna", "meaning": "having Xed (for oneself)", "declinable": True},
            "future_passive": {"suffix": "tabba", "meaning": "to be Xed", "declinable": True},
            "future_passive_2": {"suffix": "anƒ´ya", "meaning": "should be Xed", "declinable": True},
            "future_active": {"suffix": "ssant", "meaning": "about to X", "declinable": True},
            "perfect_active": {"suffix": "vant", "meaning": "having Xed", "declinable": True},
            "gerund": {"suffix": "tvƒÅ", "meaning": "having Xed", "declinable": False},
            "gerund_prefixed": {"suffix": "ya", "meaning": "having Xed (with prefix)", "declinable": False},
            "infinitive": {"suffix": "tu·πÉ", "meaning": "to X", "declinable": False},
            "absolutive": {"suffix": "tvƒÅna", "meaning": "having Xed", "declinable": False},
            "conditional_participle": {"suffix": "ce", "meaning": "if Xing", "declinable": False},
            "temporal_participle": {"suffix": "kƒÅle", "meaning": "when Xing", "declinable": False}
        }
        
        genders = ["masculine", "feminine", "neuter"]
        numbers = ["singular", "dual", "plural"]
        cases = ["nominative", "accusative", "instrumental", "dative", "ablative", "genitive", "locative", "vocative"]
        
        # Process ALL roots
        for root, root_data in self.kb.root_meanings.items():
            clean_root = root.replace("‚àö", "")
            
            for p_type, p_info in participle_types.items():
                # Generate base participle
                base_participle = self._generate_participle_base(clean_root, p_type, p_info, root_data)
                
                if not base_participle:
                    continue
                
                if not p_info["declinable"]:
                    # Indeclinable participle
                    if (base_participle not in self.existing_words and 
                        base_participle not in self.generated_dict):
                        
                        meaning = f"{root_data.get('meaning', root)} ({p_info['meaning']})"
                        
                        entry = {
                            "word": base_participle,
                            "meaning": self.validator.enhance_meaning(meaning),
                            "type": "participle",
                            "participle_type": p_type,
                            "root": root,
                            "indeclinable": True,
                            "frequency": 3.0
                        }
                        
                        self.generated_dict[base_participle] = entry
                        count += 1
                
                else:
                    # Declinable participle - generate ALL forms
                    for gender in genders:
                        for number in numbers:
                            for case in cases:
                                form = self._apply_participle_declension(
                                    base_participle, p_type, gender, number, case
                                )
                                
                                if (form and form not in self.existing_words and 
                                    form not in self.generated_dict):
                                    
                                    # Generate meaning
                                    meaning = self.morphological_generator.generate_participle_meaning(
                                        root, p_type, gender, number
                                    )
                                    
                                    # Add case information
                                    case_meaning = self.morphological_generator.case_templates[case]["default"]
                                    full_meaning = case_meaning.format(meaning)
                                    
                                    # Validate
                                    is_valid, _ = self.validator.validate_meaning(full_meaning)
                                    if is_valid:
                                        entry = {
                                            "word": form,
                                            "meaning": self.validator.enhance_meaning(full_meaning),
                                            "type": "participle",
                                            "participle_type": p_type,
                                            "root": root,
                                            "gender": gender,
                                            "number": number,
                                            "case": case,
                                            "semantic_field": root_data.get("semantic_field", "action"),
                                            "frequency": 2.5
                                        }
                                        
                                        self.generated_dict[form] = entry
                                        count += 1
        
        return count
    
    def _generate_all_comparison_forms(self):
        """Generate ALL comparative and superlative forms"""
        count = 0
        
        # Get ALL adjective-like words
        adjective_words = []
        
        # From base words
        for word, info in self.kb.base_meanings.items():
            if (info.get("semantic_field") in ["qualities", "colors", "mental_factors"] or 
                info.get("pos") == "adjective"):
                adjective_words.append(word)
        
        # From semantic fields
        for field in ["qualities", "mental_factors", "emotions"]:
            if field in self.kb.semantic_fields:
                adjective_words.extend(self.kb.semantic_fields[field])
        
        # Remove duplicates
        adjective_words = list(set(adjective_words))
        
        # Generate ALL comparison forms
        for adj in adjective_words:
            # Comparative forms (-tara, -iya)
            comp_suffixes = ["-tara", "-iya"]
            for suffix in comp_suffixes:
                form = adj + suffix.replace("-", "")
                
                if (form not in self.existing_words and 
                    form not in self.generated_dict):
                    
                    base_meaning = self._get_base_meaning(adj)
                    meaning = f"more {base_meaning}, rather {base_meaning}"
                    
                    entry = {
                        "word": form,
                        "meaning": self.validator.enhance_meaning(meaning),
                        "type": "derivative_comparison",
                        "base": adj,
                        "degree": "comparative",
                        "suffix": suffix,
                        "frequency": 2.5
                    }
                    
                    self.generated_dict[form] = entry
                    count += 1
            
            # Superlative forms (-tama, -i·π≠·π≠ha)
            sup_suffixes = ["-tama", "-i·π≠·π≠ha"]
            for suffix in sup_suffixes:
                form = adj + suffix.replace("-", "")
                
                if (form not in self.existing_words and 
                    form not in self.generated_dict):
                    
                    base_meaning = self._get_base_meaning(adj)
                    meaning = f"most {base_meaning}, very {base_meaning}"
                    
                    entry = {
                        "word": form,
                        "meaning": self.validator.enhance_meaning(meaning),
                        "type": "derivative_comparison",
                        "base": adj,
                        "degree": "superlative",
                        "suffix": suffix,
                        "frequency": 2.5
                    }
                    
                    self.generated_dict[form] = entry
                    count += 1
        
        return count
    
    def _generate_all_denominative_forms(self):
        """Generate ALL denominative verb forms"""
        count = 0
        
        patterns = {
            "-ƒÅyati": "acts like X, desires X",
            "-iyati": "behaves as X", 
            "-eti": "makes into X",
            "-ƒÅpeti": "causes to become X",
            "-karoti": "does X",
            "-bhavati": "becomes X"
        }
        
        # Select ALL suitable nouns
        noun_bases = []
        for word, info in self.kb.base_meanings.items():
            if info.get("semantic_field") in ["beings", "qualities", "emotions", "mind", "society", "nature"]:
                noun_bases.append(word)
        
        # Generate denominative verbs for ALL bases
        for base in noun_bases:
            for suffix, meaning_template in patterns.items():
                # Generate ALL persons, numbers, tenses
                for tense in ["present", "aorist", "future", "imperative", "optative"]:
                    for person in ["1st", "2nd", "3rd"]:
                        for number in ["singular", "dual", "plural"]:
                            # Skip certain combinations
                            if tense == "imperative" and person == "1st" and number == "singular":
                                continue
                            
                            form = self._generate_denominative_form(base, suffix, person, number, tense)
                            
                            if (form and form not in self.existing_words and 
                                form not in self.generated_dict):
                                
                                base_meaning = self._get_base_meaning(base)
                                template_meaning = meaning_template.replace("X", base_meaning)
                                
                                # Add tense/person info
                                tense_template = self.morphological_generator.tense_templates[tense]["active"]
                                verbal_meaning = tense_template.format(template_meaning)
                                pronoun = self.morphological_generator._get_pronoun(person, number)
                                final_meaning = f"({pronoun}) {verbal_meaning}"
                                
                                entry = {
                                    "word": form,
                                    "meaning": self.validator.enhance_meaning(final_meaning),
                                    "type": "derivative_denominative_verbs",
                                    "base": base,
                                    "suffix": suffix,
                                    "person": person,
                                    "number": number,
                                    "tense": tense,
                                    "frequency": 2.0
                                }
                                
                                self.generated_dict[form] = entry
                                count += 1
        
        return count
    
    def _generate_complete_prefixed_universe(self):
        """Generate ALL possible prefixed forms"""
        count = 0
        
        # Phase A: ALL single-prefix combinations
        print("   üìù Generating ALL single-prefix combinations...")
        count += self._generate_all_single_prefix_combinations()
        
        # Phase B: ALL double-prefix combinations
        print("   üìù Generating ALL double-prefix combinations...")
        count += self._generate_all_double_prefix_combinations()
        
        # Phase C: Triple-prefix combinations (rare but possible)
        print("   üìù Generating triple-prefix combinations...")
        count += self._generate_triple_prefix_combinations()
        
        print(f"   ‚úÖ Generated {count} prefixed forms total")
        self.generation_stats["prefixed_verbs"] = count
        return count
    
    def _generate_all_single_prefix_combinations(self):
        """Generate ALL single prefix combinations"""
        count = 0
        
        # Get ALL prefixes
        all_prefixes = list(self.kb.prefix_meanings.keys())
        
        # Process ALL roots
        for root, root_data in self.kb.root_meanings.items():
            for prefix in all_prefixes:
                # Generate multiple tenses and forms
                for tense in ["present", "aorist", "future", "imperative", "optative", "conditional"]:
                    for person in ["1st", "2nd", "3rd"]:
                        for number in ["singular", "dual", "plural"]:
                            # Skip certain combinations
                            if self._should_skip_verbal_form(tense, person, number, "active"):
                                continue
                            
                            # Get base form
                            base_form = self._apply_verbal_morphology(root, person, number, tense)
                            
                            if base_form:
                                # Apply prefix with sandhi
                                prefixed_form = self._apply_prefix_sandhi(prefix, base_form)
                                
                                if (prefixed_form not in self.existing_words and 
                                    prefixed_form not in self.generated_dict):
                                    
                                    # Generate meaning
                                    prefix_meaning = self.kb.prefix_meanings.get(prefix, prefix)
                                    root_meaning = root_data.get("meaning", root)
                                    
                                    # Compose meaning
                                    combined_meaning = f"{prefix_meaning} {root_meaning}"
                                    tense_template = self.morphological_generator.tense_templates[tense]["active"]
                                    verbal_meaning = tense_template.format(combined_meaning)
                                    pronoun = self.morphological_generator._get_pronoun(person, number)
                                    full_meaning = f"({pronoun}) {verbal_meaning}"
                                    
                                    entry = {
                                        "word": prefixed_form,
                                        "meaning": self.validator.enhance_meaning(full_meaning),
                                        "type": "prefixed_verb",
                                        "root": root,
                                        "prefix": prefix,
                                        "person": person,
                                        "number": number,
                                        "tense": tense,
                                        "semantic_field": root_data.get("semantic_field", "action"),
                                        "frequency": 3.5
                                    }
                                    
                                    self.generated_dict[prefixed_form] = entry
                                    count += 1
                
                # Also generate participles with prefixes
                count += self._generate_single_prefix_participles(root, prefix, root_data)
        
        return count
    
    def _generate_all_double_prefix_combinations(self):
        """Generate ALL double prefix combinations"""
        count = 0
        
        # Extended double-prefix combinations
        double_prefixes = [
            ("sam", "anu"), ("sam", "pa"), ("sam", "pari"), ("sam", "ud"), ("sam", "ƒÅ"),
            ("pari", "ni"), ("pari", "ƒÅ"), ("pari", "ud"), ("pari", "pa"),
            ("vi", "pa"), ("vi", "ni"), ("vi", "ƒÅ"), ("vi", "sam"), ("vi", "pari"),
            ("anu", "pa"), ("anu", "vi"), ("anu", "sam"), ("anu", "pari"),
            ("pa", "ni"), ("pa", "vi"), ("pa", "ƒÅ"), ("pa", "ud"),
            ("ud", "pa"), ("ud", "ƒÅ"), ("ud", "sam"), ("ud", "vi"),
            ("ni", "pa"), ("ni", "vi"), ("ni", "sam"), ("ni", "ƒÅ"),
            ("ƒÅ", "pa"), ("ƒÅ", "vi"), ("ƒÅ", "sam"), ("ƒÅ", "pari"),
            ("abhi", "sam"), ("abhi", "ƒÅ"), ("abhi", "vi"), ("abhi", "ud"),
            ("adhi", "·π≠hƒÅ"), ("adhi", "vas"), ("adhi", "gam"), ("adhi", "kar")
        ]
        
        # Select high-frequency roots
        frequent_roots = [
            root for root, info in self.kb.root_meanings.items()
            if info.get("frequency") == "high"
        ]
        
        # If no frequency info, use first 100 roots
        if not frequent_roots:
            frequent_roots = list(self.kb.root_meanings.keys())[:100]
        
        for prefix1, prefix2 in double_prefixes:
            for root in frequent_roots:
                # Generate select forms
                for tense in ["present", "aorist", "future"]:
                    for person in ["3rd"]:  # Focus on 3rd person
                        for number in ["singular", "plural"]:
                            # Get base form
                            base_form = self._apply_verbal_morphology(root, person, number, tense)
                            
                            if base_form:
                                # Apply both prefixes with sandhi
                                step1 = self._apply_prefix_sandhi(prefix2, base_form)
                                prefixed_form = self._apply_prefix_sandhi(prefix1, step1)
                                
                                if (prefixed_form not in self.existing_words and 
                                    prefixed_form not in self.generated_dict):
                                    
                                    # Generate meaning
                                    prefix1_meaning = self.kb.prefix_meanings.get(prefix1, prefix1)
                                    prefix2_meaning = self.kb.prefix_meanings.get(prefix2, prefix2)
                                    root_meaning = self.kb.root_meanings[root].get("meaning", root)
                                    
                                    combined_meaning = f"{prefix1_meaning} {prefix2_meaning} {root_meaning}"
                                    
                                    tense_template = self.morphological_generator.tense_templates[tense]["active"]
                                    verbal_meaning = tense_template.format(combined_meaning)
                                    pronoun = self.morphological_generator._get_pronoun(person, number)
                                    full_meaning = f"({pronoun}) {verbal_meaning}"
                                    
                                    entry = {
                                        "word": prefixed_form,
                                        "meaning": self.validator.enhance_meaning(full_meaning),
                                        "type": "prefixed_verb",
                                        "root": root,
                                        "prefix": f"{prefix1}+{prefix2}",
                                        "person": person,
                                        "number": number,
                                        "tense": tense,
                                        "prefix_type": "double",
                                        "frequency": 2.5
                                    }
                                    
                                    self.generated_dict[prefixed_form] = entry
                                    count += 1
        
        return count
    
    def _generate_triple_prefix_combinations(self):
        """Generate triple prefix combinations (very rare)"""
        count = 0
        
        # Only most common triple combinations
        triple_prefixes = [
            ("sam", "ƒÅ", "pa"), ("sam", "pari", "ƒÅ"), ("vi", "sam", "ƒÅ"),
            ("anu", "sam", "pa"), ("pari", "sam", "ƒÅ"), ("abhi", "sam", "ƒÅ")
        ]
        
        # Only highest frequency roots
        top_roots = ["‚àögam", "‚àökar", "‚àöbh≈´", "‚àö·π≠hƒÅ", "‚àödis"]
        
        for prefix1, prefix2, prefix3 in triple_prefixes:
            for root in top_roots:
                if root in self.kb.root_meanings:
                    # Generate only present 3rd singular
                    base_form = self._apply_verbal_morphology(root, "3rd", "singular", "present")
                    
                    if base_form:
                        # Apply all three prefixes
                        step1 = self._apply_prefix_sandhi(prefix3, base_form)
                        step2 = self._apply_prefix_sandhi(prefix2, step1)
                        prefixed_form = self._apply_prefix_sandhi(prefix1, step2)
                        
                        if (prefixed_form not in self.existing_words and 
                            prefixed_form not in self.generated_dict):
                            
                            # Generate meaning
                            prefix1_meaning = self.kb.prefix_meanings.get(prefix1, prefix1)
                            prefix2_meaning = self.kb.prefix_meanings.get(prefix2, prefix2)
                            prefix3_meaning = self.kb.prefix_meanings.get(prefix3, prefix3)
                            root_meaning = self.kb.root_meanings[root].get("meaning", root)
                            
                            combined_meaning = f"{prefix1_meaning} {prefix2_meaning} {prefix3_meaning} {root_meaning}"
                            
                            entry = {
                                "word": prefixed_form,
                                "meaning": self.validator.enhance_meaning(f"(he/she/it) {combined_meaning}s"),
                                "type": "prefixed_verb",
                                "root": root,
                                "prefix": f"{prefix1}+{prefix2}+{prefix3}",
                                "person": "3rd",
                                "number": "singular",
                                "tense": "present",
                                "prefix_type": "triple",
                                "frequency": 1.5,
                                "rare": True
                            }
                            
                            self.generated_dict[prefixed_form] = entry
                            count += 1
        
        return count
    
    def _generate_unlimited_compounds(self):
        """Generate unlimited compounds"""
        count = 0
        
        # Use the ultimate compositor
        compounds = self.compound_compositor.generate_unlimited_compounds(
            self.kb.semantic_fields,
            max_total=self.limits["compounds_per_type"]
        )
        
        for compound, compound_info in compounds.items():
            if (compound not in self.existing_words and 
                compound not in self.generated_dict):
                
                entry = {
                    "word": compound,
                    "meaning": self.validator.enhance_meaning(compound_info["meaning"]),
                    "type": f"compound_{compound_info['type']}",
                    "components": compound_info["components"],
                    "pattern": compound_info.get("pattern", ""),
                    "semantic_field": "compound",
                    "frequency": compound_info.get("frequency", 2.5)
                }
                
                # Add depth for recursive compounds
                if "depth" in compound_info:
                    entry["depth"] = compound_info["depth"]
                    entry["base_compound"] = compound_info.get("base_compound", "")
                
                self.generated_dict[compound] = entry
                count += 1
        
        print(f"   ‚úÖ Generated {count} unlimited compounds")
        self.generation_stats["compounds"] = count
        return count
    
    def _generate_complete_derivational_universe(self):
        """Generate ALL possible derivatives"""
        count = 0
        
        # Process ALL derivation patterns without limits
        for category, patterns in self.kb.derivation_patterns.items():
            print(f"      ‚Ä¢ Generating ALL {category}...")
            category_count = 0
            
            for suffix, suffix_info in patterns.items():
                # Select ALL appropriate base words
                if category in ["verbal_nouns", "agent_nouns"]:
                    # Use ALL roots
                    bases = list(self.kb.root_meanings.keys())
                else:
                    # Use ALL suitable base words
                    bases = [
                        w for w in self.kb.base_meanings.keys() 
                        if self.kb.base_meanings[w].get("semantic_field") not in ["particles"]
                    ]
                
                # Generate derivatives for ALL bases (no limits)
                for base in bases:
                    form = base.replace("‚àö", "") + suffix.replace("-", "")
                    
                    if (form not in self.existing_words and 
                        form not in self.generated_dict):
                        
                        # Generate meaning with context
                        semantic_context = self._determine_semantic_context(base, category)
                        derivative_meaning = self.derivational_generator.generate_derivative_meaning(
                            base, suffix, category, semantic_context
                        )
                        
                        entry = {
                            "word": form,
                            "meaning": self.validator.enhance_meaning(derivative_meaning),
                            "type": f"derivative_{category}",
                            "base": base,
                            "suffix": suffix,
                            "frequency": self._calculate_derivative_frequency(base, suffix, category)
                        }
                        
                        # Add gender if specified
                        if "gender" in suffix_info:
                            entry["gender"] = suffix_info["gender"]
                        
                        self.generated_dict[form] = entry
                        count += 1
                        category_count += 1
            
            print(f"        ‚úì {category_count} {category}")
        
        # Generate ALL secondary derivatives
        print("      ‚Ä¢ Generating ALL secondary derivatives...")
        secondary_count = self._generate_all_secondary_derivatives()
        count += secondary_count
        
        # Generate ALL tertiary derivatives
        print("      ‚Ä¢ Generating tertiary derivatives...")
        tertiary_count = self._generate_tertiary_derivatives()
        count += tertiary_count
        
        print(f"   ‚úÖ Generated {count} derivative forms total")
        self.generation_stats["derivatives"] = count
        return count
    
    def _generate_all_secondary_derivatives(self):
        """Generate ALL secondary derivatives"""
        count = 0
        
        # Extended patterns for secondary derivation
        secondary_patterns = {
            "-tƒÅ": ["abstract_nouns", "state of being X"],
            "-tva": ["abstract_nouns", "nature of X"],
            "-ya": ["abstract_nouns", "condition of X"],
            "-ka": ["diminutives", "little X"],
            "-ika": ["possessive_adjectives", "connected with X"],
            "-ika": ["agent_nouns", "one who does X"],
            "-tara": ["comparison", "more X"],
            "-tama": ["comparison", "most X"]
        }
        
        # Find ALL existing derivatives
        primary_derivatives = [
            (word, entry) for word, entry in self.generated_dict.items()
            if entry["type"].startswith("derivative_") and 
            entry["type"] not in ["derivative_abstract_nouns", "derivative_comparison"]
        ]
        
        for primary_word, primary_entry in primary_derivatives:
            for suffix, (category, meaning_pattern) in secondary_patterns.items():
                secondary_form = primary_word + suffix.replace("-", "")
                
                if (secondary_form not in self.existing_words and 
                    secondary_form not in self.generated_dict):
                    
                    # Generate meaning
                    secondary_meaning = self.derivational_generator.generate_secondary_derivative(
                        primary_word, suffix, category
                    )
                    
                    entry = {
                        "word": secondary_form,
                        "meaning": self.validator.enhance_meaning(secondary_meaning),
                        "type": f"derivative_{category}",
                        "base": primary_word,
                        "primary_base": primary_entry.get("base", ""),
                        "suffix": suffix,
                        "derivation_level": "secondary",
                        "frequency": primary_entry.get("frequency", 2.0) * 0.8
                    }
                    
                    self.generated_dict[secondary_form] = entry
                    count += 1
        
        return count
    
    def _generate_tertiary_derivatives(self):
        """Generate tertiary derivatives (derivatives of derivatives of derivatives)"""
        count = 0
        
        # Only most productive patterns for tertiary
        tertiary_patterns = {
            "-tƒÅ": "state of being X",
            "-ka": "little X"
        }
        
        # Find secondary derivatives
        secondary_derivatives = [
            (word, entry) for word, entry in self.generated_dict.items()
            if entry.get("derivation_level") == "secondary"
        ][:500]  # Limit to avoid explosion
        
        for secondary_word, secondary_entry in secondary_derivatives:
            for suffix, meaning_pattern in tertiary_patterns.items():
                tertiary_form = secondary_word + suffix.replace("-", "")
                
                if (tertiary_form not in self.existing_words and 
                    tertiary_form not in self.generated_dict):
                    
                    # Generate meaning
                    secondary_meaning = secondary_entry["meaning"]
                    tertiary_meaning = meaning_pattern.replace("X", secondary_meaning)
                    
                    entry = {
                        "word": tertiary_form,
                        "meaning": self.validator.enhance_meaning(tertiary_meaning),
                        "type": "derivative_abstract_nouns",
                        "base": secondary_word,
                        "secondary_base": secondary_entry.get("base", ""),
                        "primary_base": secondary_entry.get("primary_base", ""),
                        "suffix": suffix,
                        "derivation_level": "tertiary",
                        "frequency": secondary_entry.get("frequency", 2.0) * 0.7,
                        "rare": True
                    }
                    
                    self.generated_dict[tertiary_form] = entry
                    count += 1
        
        return count
    
    def _generate_complete_technical_vocabulary(self):
        """Generate ALL technical vocabulary"""
        count = 0
        
        # Generate from comprehensive technical vocabulary
        if hasattr(self.kb, 'comprehensive_technical_vocabulary'):
            for field, terms in self.kb.comprehensive_technical_vocabulary.items():
                print(f"   üìù Processing {field} ({len(terms)} terms)...")
                field_count = 0
                
                for term in terms:
                    if term not in self.existing_words and term not in self.generated_dict:
                        # Create technical term entry
                        if term in self.kb.base_meanings:
                            base_meaning = self.kb.base_meanings[term]["primary"]
                            technical_meaning = f"{base_meaning} (technical term in {field})"
                        else:
                            technical_meaning = f"technical term in {field}"
                        
                        entry = {
                            "word": term,
                            "meaning": self.validator.enhance_meaning(technical_meaning),
                            "type": "technical_term",
                            "field": field,
                            "semantic_field": field,
                            "register": "technical",
                            "frequency": 3.0
                        }
                        
                        self.generated_dict[term] = entry
                        count += 1
                        field_count += 1
                        
                        # Generate ALL inflected forms for technical terms
                        tech_forms = self._generate_all_technical_inflections(term, field)
                        count += tech_forms
                        field_count += tech_forms
                
                print(f"      ‚úì {field_count} entries for {field}")
        
        self.generation_stats["technical_terms"] = count
        return count
    
    def _generate_all_technical_inflections(self, term, field):
        """Generate ALL inflected forms for technical terms"""
        count = 0
        
        # ALL cases and numbers for technical terms
        all_cases = ["nominative", "accusative", "instrumental", "dative", 
                    "ablative", "genitive", "locative", "vocative"]
        all_numbers = ["singular", "dual", "plural"]
        
        for case in all_cases:
            for number in all_numbers:
                form = self._apply_nominal_morphology(term, case, number)
                
                if (form and form != term and 
                    form not in self.existing_words and 
                    form not in self.generated_dict):
                    
                    case_meaning = self.morphological_generator.case_templates[case]["default"]
                    base_meaning = f"{term} (technical term in {field})"
                    full_meaning = case_meaning.format(base_meaning)
                    
                    entry = {
                        "word": form,
                        "meaning": self.validator.enhance_meaning(full_meaning),
                        "type": "inflected_noun",
                        "base": term,
                        "case": case,
                        "number": number,
                        "field": field,
                        "register": "technical",
                        "frequency": 2.5
                    }
                    
                    self.generated_dict[form] = entry
                    count += 1
        
        return count
    
    def _generate_complete_phrasal_universe(self):
        """Generate ALL phrasal expressions"""
        count = 0
        
        # Process phrasal expressions
        if hasattr(self.kb, 'phrasal_expressions'):
            for phrase, meaning in self.kb.phrasal_expressions.items():
                if phrase not in self.existing_words and phrase not in self.generated_dict:
                    entry = {
                        "word": phrase,
                        "meaning": self.validator.enhance_meaning(meaning),
                        "type": "phrasal_expression",
                        "components": phrase.split("-"),
                        "frequency": 3.5
                    }
                    
                    self.generated_dict[phrase] = entry
                    count += 1
        
        # Process liturgical formulas
        if hasattr(self.kb, 'liturgical_formulas'):
            for formula, meaning in self.kb.liturgical_formulas.items():
                if formula not in self.existing_words and formula not in self.generated_dict:
                    entry = {
                        "word": formula,
                        "meaning": self.validator.enhance_meaning(meaning),
                        "type": "liturgical_formula",
                        "register": "ceremonial",
                        "frequency": 2.5
                    }
                    
                    self.generated_dict[formula] = entry
                    count += 1
        
        self.generation_stats["phrasal_expressions"] = count
        return count
    
    def _generate_complete_numerical_universe(self):
        """Generate ALL numerical expressions"""
        count = 0
        
        # Process complete numerals
        if hasattr(self.kb, 'complete_numerals'):
            for numeral, info in self.kb.complete_numerals.items():
                if numeral not in self.existing_words and numeral not in self.generated_dict:
                    entry = {
                        "word": numeral,
                        "meaning": self.validator.enhance_meaning(info["meaning"]),
                        "type": f"numeral_{info['type']}",
                        "value": info["value"],
                        "numeral_type": info["type"],
                        "frequency": 4.0 if info["value"] <= 10 else 3.0
                    }
                    
                    if "gender" in info:
                        entry["gender"] = info["gender"]
                    
                    self.generated_dict[numeral] = entry
                    count += 1
                    
                    # Generate inflected forms for declinable numerals
                    if info["type"] in ["cardinal", "ordinal"] and info["value"] <= 100:
                        inflected_count = self._generate_numeral_inflections(numeral, info)
                        count += inflected_count
        
        # Generate ALL number + noun combinations
        count += self._generate_all_numerical_compounds()
        
        self.generation_stats["numerals"] = count
        return count
    
    def _generate_all_numerical_compounds(self):
        """Generate ALL number + noun combinations"""
        count = 0
        
        # Get numbers up to 1000
        numbers = []
        if hasattr(self.kb, 'complete_numerals'):
            for numeral, info in self.kb.complete_numerals.items():
                if (info["type"] == "cardinal" and 
                    isinstance(info["value"], int) and 
                    info["value"] <= 1000):
                    numbers.append((numeral, info["value"], info["meaning"]))
        
        # Get countable nouns
        countable_nouns = []
        for word, info in self.kb.base_meanings.items():
            if info.get("semantic_field") not in ["particles", "prefixes", "abstract"]:
                countable_nouns.append(word)
        
        # Common patterns with numbers
        patterns = [
            ("X", "Y", "X Y"),
            ("X", "Y", "Y of X"),
            ("X", "divasa", "X days"),
            ("X", "ratti", "X nights"),
            ("X", "mƒÅsa", "X months"),
            ("X", "vassa", "X years"),
            ("X", "vƒÅra", "X times"),
            ("X", "kkhatta·πÉ", "X times"),
            ("X", "bhƒÅga", "X parts"),
            ("X", "ko·π≠i", "X crores"),
            ("X", "gƒÅthƒÅ", "X verses"),
            ("X", "sutta", "X discourses")
        ]
        
        # Generate combinations
        for num_word, num_value, num_meaning in numbers[:50]:  # Limit to first 50 numbers
            for pattern in patterns:
                if pattern[1] == "Y":
                    # General pattern - use countable nouns
                    for noun in countable_nouns[:20]:  # Limit nouns
                        compound = self._apply_compound_sandhi([num_word, noun])
                        meaning = pattern[2].replace("X", num_meaning).replace("Y", self._get_base_meaning(noun))
                        
                        if (compound not in self.existing_words and 
                            compound not in self.generated_dict):
                            
                            entry = {
                                "word": compound,
                                "meaning": self.validator.enhance_meaning(meaning),
                                "type": "numerical_compound",
                                "components": [num_word, noun],
                                "number": num_value,
                                "frequency": 3.0 if num_value <= 10 else 2.5
                            }
                            
                            self.generated_dict[compound] = entry
                            count += 1
                else:
                    # Specific pattern
                    compound = self._apply_compound_sandhi([num_word, pattern[1]])
                    meaning = pattern[2].replace("X", num_meaning)
                    
                    if (compound not in self.existing_words and 
                        compound not in self.generated_dict):
                        
                        entry = {
                            "word": compound,
                            "meaning": self.validator.enhance_meaning(meaning),
                            "type": "numerical_compound",
                            "components": [num_word, pattern[1]],
                            "number": num_value,
                            "pattern": pattern[0] + "+" + pattern[1],
                            "frequency": 3.0 if num_value <= 10 else 2.5
                        }
                        
                        self.generated_dict[compound] = entry
                        count += 1
        
        return count
    
    def _generate_complete_sandhi_universe(self):
        """Generate ALL possible sandhi variants"""
        count = 0
        
        # Phase A: Compound boundary sandhi
        print("   üìù Generating ALL compound boundary sandhi...")
        count += self._generate_all_compound_boundary_sandhi()
        
        # Phase B: Word combination sandhi
        print("   üìù Generating ALL word combination sandhi...")
        count += self._generate_all_word_combination_sandhi()
        
        # Phase C: Internal sandhi variants
        print("   üìù Generating ALL internal sandhi variants...")
        count += self._generate_all_internal_sandhi_variants()
        
        print(f"   ‚úÖ Generated {count} sandhi variants total")
        self.generation_stats["sandhi_variants"] = count
        return count
    
    def _generate_all_compound_boundary_sandhi(self):
        """Generate ALL compound boundary sandhi variants"""
        count = 0
        
        # Get ALL compound entries
        compound_entries = [
            (word, entry) for word, entry in self.generated_dict.items()
            if entry["type"].startswith("compound_") and "components" in entry
        ]
        
        for compound_word, compound_entry in compound_entries:
            components = compound_entry["components"]
            
            if len(components) >= 2:
                # Try alternative sandhi at each boundary
                for i in range(len(components) - 1):
                    first = components[i]
                    second = components[i + 1]
                    
                    # Get ALL possible sandhi alternatives
                    alternatives = self._get_all_sandhi_alternatives(first, second)
                    
                    for alt_sandhi in alternatives:
                        # Reconstruct compound with alternative sandhi
                        new_components = components[:i] + [alt_sandhi] + components[i+2:]
                        variant = "".join(new_components)
                        
                        if (variant != compound_word and 
                            variant not in self.existing_words and 
                            variant not in self.generated_dict):
                            
                            entry = {
                                "word": variant,
                                "meaning": compound_entry["meaning"] + " (alternative sandhi)",
                                "type": "sandhi_variant",
                                "base": compound_word,
                                "components": components,
                                "sandhi_boundary": i,
                                "sandhi_type": "compound_boundary",
                                "frequency": compound_entry.get("frequency", 2.0) * 0.9
                            }
                            
                            self.generated_dict[variant] = entry
                            count += 1
        
        return count
    
    def _generate_all_word_combination_sandhi(self):
        """Generate ALL word combination sandhi"""
        count = 0
        
        # Extended combiners
        common_combiners = {
            "particles": ["ca", "vƒÅ", "api", "eva", "iti", "ti", "nu", "kho", "pana", "hi", "tu"],
            "pronouns": ["aya·πÉ", "ida·πÉ", "eta·πÉ", "ta·πÉ", "ya·πÉ", "ki·πÉ", "so", "sƒÅ", "te"],
            "negations": ["na", "no", "mƒÅ", "natthi"],
            "prefixes": list(self.kb.prefix_meanings.keys())[:20]
        }
        
        # Select high-frequency words
        high_freq_words = [
            word for word, entry in self.generated_dict.items()
            if entry.get("frequency", 0) >= 4.0 and len(word) < 12
        ][:200]  # Increased limit
        
        # Generate ALL combinations
        for category, combiners in common_combiners.items():
            for combiner in combiners:
                for word in high_freq_words:
                    # Try both orders
                    for combo in [(combiner, word), (word, combiner)]:
                        first, second = combo
                        
                        # Apply ALL possible sandhi
                        combined_variants = self._apply_all_sandhi_to_combination(first, second)
                        
                        for combined in combined_variants:
                            if (combined and 
                                combined != first + second and
                                combined not in self.existing_words and 
                                combined not in self.generated_dict and
                                len(combined) > 2):
                                
                                # Generate meaning
                                first_meaning = self._get_word_meaning_for_combination(first)
                                second_meaning = self._get_word_meaning_for_combination(second)
                                
                                combined_meaning = self._compose_combination_meaning(
                                    first_meaning, second_meaning, category
                                )
                                
                                entry = {
                                    "word": combined,
                                    "meaning": self.validator.enhance_meaning(combined_meaning),
                                    "type": "sandhi_variant",
                                    "components": [first, second],
                                    "category": f"{category}_combination",
                                    "sandhi_type": "word_combination",
                                    "frequency": 2.0
                                }
                                
                                self.generated_dict[combined] = entry
                                count += 1
        
        
